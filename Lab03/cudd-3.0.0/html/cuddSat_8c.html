<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>cudd: cudd/cuddSat.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">cudd&#160;<span id="projectnumber">3.0.0</span></div>
   <div id="projectbrief">The University of Colorado Decision Diagram Package</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Defines</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>cudd/cuddSat.c File Reference<div class="ingroups"><a class="el" href="group__cudd.html">cudd</a></div></h1>  </div>
</div>
<div class="contents">

<p>Functions for the solution of satisfiability related problems.  
<a href="#_details">More...</a></p>
<div class="textblock"><code>#include &quot;util.h&quot;</code><br/>
<code>#include &quot;<a class="el" href="cuddInt_8h_source.html">cuddInt.h</a>&quot;</code><br/>
</div><div class="textblock"><div class="dynheader">
Include dependency graph for cuddSat.c:</div>
<div class="dyncontent">
<div class="center"><img src="cuddSat_8c__incl.png" border="0" usemap="#cudd_2cuddSat_8c" alt=""/></div>
<map name="cudd_2cuddSat_8c" id="cudd_2cuddSat_8c">
<area shape="rect" id="node3" href="cuddInt_8h.html" title="Internal data structures of the CUDD package." alt="" coords="239,80,315,107"/><area shape="rect" id="node5" href="config_8h_source.html" title="config.h" alt="" coords="91,155,159,181"/><area shape="rect" id="node9" href="cudd_8h.html" title="The University of Colorado decision diagram package." alt="" coords="407,155,468,181"/></map>
</div>
</div><table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcuddPathPair.html">cuddPathPair</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of item stored in memoization table.  <a href="structcuddPathPair.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6994699d7a2a82b8f838e9d8d408095a"></a><!-- doxytag: member="cuddSat.c::DD_BIGGY" ref="a6994699d7a2a82b8f838e9d8d408095a" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>DD_BIGGY</b>&#160;&#160;&#160;100000000</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa0c21b2677d4dc06dfd0dd175bb1a718"></a><!-- doxytag: member="cuddSat.c::WEIGHT" ref="aa0c21b2677d4dc06dfd0dd175bb1a718" args="(weight, col)" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>WEIGHT</b>(weight, col)&#160;&#160;&#160;((weight) == NULL ? 1 : weight[col])</td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9652826593b0f67d77dc1152dacb93f7"></a><!-- doxytag: member="cuddSat.c::cuddPathPair" ref="a9652826593b0f67d77dc1152dacb93f7" args="" -->
typedef struct <a class="el" href="structcuddPathPair.html">cuddPathPair</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddSat_8c.html#a9652826593b0f67d77dc1152dacb93f7">cuddPathPair</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of item stored in memoization table. <br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddSat_8c.html#a0f11262fedecf0c0f4376432b478e6e8">Cudd_Eval</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, int *inputs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of a DD for a given variable assignment.  <a href="#a0f11262fedecf0c0f4376432b478e6e8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddSat_8c.html#a78e2d36d1fdfa3d917ad345867bd4596">Cudd_ShortestPath</a> (<a class="el" href="structDdManager.html">DdManager</a> *manager, <a class="el" href="structDdNode.html">DdNode</a> *f, int *weight, int *support, int *length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a shortest path in a DD.  <a href="#a78e2d36d1fdfa3d917ad345867bd4596"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddSat_8c.html#a5722a5bf76d99cd30783ad87ba03bf96">Cudd_LargestCube</a> (<a class="el" href="structDdManager.html">DdManager</a> *manager, <a class="el" href="structDdNode.html">DdNode</a> *f, int *length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a largest cube in a DD.  <a href="#a5722a5bf76d99cd30783ad87ba03bf96"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddSat_8c.html#addfc0e508dfd1d0bd0c74104a3dd15e8">Cudd_ShortestLength</a> (<a class="el" href="structDdManager.html">DdManager</a> *manager, <a class="el" href="structDdNode.html">DdNode</a> *f, int *weight)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the length of the shortest path(s) in a DD.  <a href="#addfc0e508dfd1d0bd0c74104a3dd15e8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddSat_8c.html#a66a70b011fca8b95fbc3953e8b1be1fe">Cudd_Decreasing</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, int i)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a BDD is negative unate in a variable.  <a href="#a66a70b011fca8b95fbc3953e8b1be1fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddSat_8c.html#a4f87b23df844d48727ee53f75d868be6">Cudd_Increasing</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, int i)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a BDD is positive unate in a variable.  <a href="#a4f87b23df844d48727ee53f75d868be6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddSat_8c.html#a3e078600dd9087c623e1bdfea00d599d">Cudd_EquivDC</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *F, <a class="el" href="structDdNode.html">DdNode</a> *G, <a class="el" href="structDdNode.html">DdNode</a> *D)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells whether F and G are identical wherever D is 0.  <a href="#a3e078600dd9087c623e1bdfea00d599d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddSat_8c.html#a5dcbf450b32f6937bc6dba252474638d">Cudd_bddLeqUnless</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *g, <a class="el" href="structDdNode.html">DdNode</a> *D)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells whether f is less than of equal to G unless D is 1.  <a href="#a5dcbf450b32f6937bc6dba252474638d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddSat_8c.html#abe0be57ead326db49e00a51d7acf75f9">Cudd_EqualSupNorm</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *g, <a class="el" href="cudd_8h.html#a84a6539cc165870dccbd296fe29ea880">CUDD_VALUE_TYPE</a> tolerance, int pr)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two ADDs for equality within tolerance.  <a href="#abe0be57ead326db49e00a51d7acf75f9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddSat_8c.html#a7b924211354f5d356009a7c804be2340">Cudd_bddMakePrime</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *cube, <a class="el" href="structDdNode.html">DdNode</a> *f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Expands cube to a prime implicant of f.  <a href="#a7b924211354f5d356009a7c804be2340"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddSat_8c.html#accb9bb89f75fe6176be961c73a19be09">Cudd_bddMaximallyExpand</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *lb, <a class="el" href="structDdNode.html">DdNode</a> *ub, <a class="el" href="structDdNode.html">DdNode</a> *f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Expands lb to prime implicants of (f and ub).  <a href="#accb9bb89f75fe6176be961c73a19be09"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddSat_8c.html#a3a45afd92abdea6f969399e7c0eb5c8f">Cudd_bddLargestPrimeUnate</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *phaseBdd)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a largest prime implicant of a unate function.  <a href="#a3a45afd92abdea6f969399e7c0eb5c8f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddSat_8c.html#aad1ef5892f9b1b85a2766956fca9761c">cuddBddMakePrime</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *cube, <a class="el" href="structDdNode.html">DdNode</a> *f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the recursive step of Cudd_bddMakePrime.  <a href="#aad1ef5892f9b1b85a2766956fca9761c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static enum <a class="el" href="st_8h.html#a0c6a172fd99de7928916e65034ed8b1f">st_retval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddSat_8c.html#a93e5bbe63d2e2598f123244b9789a731">freePathPair</a> (void *key, void *value, void *arg)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the entries of the visited symbol table.  <a href="#a93e5bbe63d2e2598f123244b9789a731"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structcuddPathPair.html">cuddPathPair</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddSat_8c.html#a3efd005d08ed4ed56179d0f0970bb2e7">getShortest</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *root, int *cost, int *support, <a class="el" href="structst__table.html">st_table</a> *visited)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the length of the shortest path(s) in a DD.  <a href="#a3efd005d08ed4ed56179d0f0970bb2e7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddSat_8c.html#aa9238a0ffa82b4ae18aec7a04ddcca24">getPath</a> (<a class="el" href="structDdManager.html">DdManager</a> *manager, <a class="el" href="structst__table.html">st_table</a> *visited, <a class="el" href="structDdNode.html">DdNode</a> *f, int *weight, int cost)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a BDD for a shortest path of f.  <a href="#aa9238a0ffa82b4ae18aec7a04ddcca24"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structcuddPathPair.html">cuddPathPair</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddSat_8c.html#a8c6ca667c717978d9377526b5466bb24">getLargest</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *root, <a class="el" href="structst__table.html">st_table</a> *visited)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the size of the largest cube(s) in a DD.  <a href="#a8c6ca667c717978d9377526b5466bb24"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddSat_8c.html#a0b6c71713bfc3fc3e45e71f63c729c4d">getCube</a> (<a class="el" href="structDdManager.html">DdManager</a> *manager, <a class="el" href="structst__table.html">st_table</a> *visited, <a class="el" href="structDdNode.html">DdNode</a> *f, int cost)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a BDD for a largest cube of f.  <a href="#a0b6c71713bfc3fc3e45e71f63c729c4d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddSat_8c.html#a68c31130d52ff1e86fbf90aa725cd95b">ddBddMaximallyExpand</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *lb, <a class="el" href="structDdNode.html">DdNode</a> *ub, <a class="el" href="structDdNode.html">DdNode</a> *f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the recursive step of Cudd_bddMaximallyExpand.  <a href="#a68c31130d52ff1e86fbf90aa725cd95b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddSat_8c.html#a9c44cbf963f2d7b8989c1fbe85c37d0b">ddBddShortestPathUnate</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, int *phases, <a class="el" href="structst__table.html">st_table</a> *table)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs shortest path computation on a unate function.  <a href="#a9c44cbf963f2d7b8989c1fbe85c37d0b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddSat_8c.html#ac4667addc7d0c7fa97bd42c265de96fd">ddGetLargestCubeUnate</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, int *phases, <a class="el" href="structst__table.html">st_table</a> *table)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts largest prime of a unate function.  <a href="#ac4667addc7d0c7fa97bd42c265de96fd"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Functions for the solution of satisfiability related problems. </p>
<dl class="author"><dt><b>Author:</b></dt><dd>Seh-Woong Jeong, Fabio Somenzi</dd></dl>
<p>Copyright (c) 1995-2015, Regents of the University of Colorado</p>
<p>All rights reserved.</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p>
<p>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</p>
<p>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</p>
<p>Neither the name of the University of Colorado nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</p>
<p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  </p>
</div><hr/><h2>Function Documentation</h2>
<a class="anchor" id="a3a45afd92abdea6f969399e7c0eb5c8f"></a><!-- doxytag: member="cuddSat.c::Cudd_bddLargestPrimeUnate" ref="a3a45afd92abdea6f969399e7c0eb5c8f" args="(DdManager *dd, DdNode *f, DdNode *phaseBdd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddLargestPrimeUnate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>phaseBdd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find a largest prime implicant of a unate function. </p>
<p>The behavior is undefined if f is not unate. The third argument is used to determine whether f is unate positive (increasing) or negative (decreasing) in each of the variables in its support.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the BDD for the prime if succesful; NULL otherwise.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddSat_8c.html#accb9bb89f75fe6176be961c73a19be09" title="Expands lb to prime implicants of (f and ub).">Cudd_bddMaximallyExpand</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>unate function </td></tr>
    <tr><td class="paramname">phaseBdd</td><td>cube of the phases </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5dcbf450b32f6937bc6dba252474638d"></a><!-- doxytag: member="cuddSat.c::Cudd_bddLeqUnless" ref="a5dcbf450b32f6937bc6dba252474638d" args="(DdManager *dd, DdNode *f, DdNode *g, DdNode *D)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_bddLeqUnless </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tells whether f is less than of equal to G unless D is 1. </p>
<p>f, g, and D are BDDs. No new nodes are created.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if f is less than of equal to G, and 0 otherwise.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddSat_8c.html#a3e078600dd9087c623e1bdfea00d599d" title="Tells whether F and G are identical wherever D is 0.">Cudd_EquivDC</a> <a class="el" href="cuddBddIte_8c.html#a89a46089e8572876a1521cdee6cb31a2" title="Checks whether f is less than or equal to g.">Cudd_bddLeq</a> <a class="el" href="cuddBddIte_8c.html#ae893c6ab0472d7058bd424d02bc9420f" title="Implements ITEconstant(f,g,h).">Cudd_bddIteConstant</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7b924211354f5d356009a7c804be2340"></a><!-- doxytag: member="cuddSat.c::Cudd_bddMakePrime" ref="a7b924211354f5d356009a7c804be2340" args="(DdManager *dd, DdNode *cube, DdNode *f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddMakePrime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>cube</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Expands cube to a prime implicant of f. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the prime if successful; NULL otherwise. In particular, NULL is returned if cube is not a real cube or is not an implicant of f.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddSat_8c.html#accb9bb89f75fe6176be961c73a19be09" title="Expands lb to prime implicants of (f and ub).">Cudd_bddMaximallyExpand</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">cube</td><td>cube to be expanded </td></tr>
    <tr><td class="paramname">f</td><td>function of which the cube is to be made a prime </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="accb9bb89f75fe6176be961c73a19be09"></a><!-- doxytag: member="cuddSat.c::Cudd_bddMaximallyExpand" ref="accb9bb89f75fe6176be961c73a19be09" args="(DdManager *dd, DdNode *lb, DdNode *ub, DdNode *f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddMaximallyExpand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Expands lb to prime implicants of (f and ub). </p>
<p>Expands lb to all prime implicants of (f and ub) that contain lb. Assumes that lb is contained in ub.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the disjunction of the primes if lb is contained in f; returns the zero BDD if lb is not contained in f; returns NULL in case of failure. In particular, NULL is returned if cube is not a real cube or is not an implicant of f. Returning the disjunction of all prime implicants works because the resulting function is unate.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddSat_8c.html#a7b924211354f5d356009a7c804be2340" title="Expands cube to a prime implicant of f.">Cudd_bddMakePrime</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">lb</td><td>cube to be expanded </td></tr>
    <tr><td class="paramname">ub</td><td>upper bound cube </td></tr>
    <tr><td class="paramname">f</td><td>function against which to expand </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a66a70b011fca8b95fbc3953e8b1be1fe"></a><!-- doxytag: member="cuddSat.c::Cudd_Decreasing" ref="a66a70b011fca8b95fbc3953e8b1be1fe" args="(DdManager *dd, DdNode *f, int i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_Decreasing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks whether a BDD is negative unate in a variable. </p>
<p>Determines whether the function represented by BDD f is negative unate (monotonic decreasing) in variable i. This function does not generate any new nodes.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the constant one is f is unate and the (logical) constant zero if it is not.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddSat_8c.html#a4f87b23df844d48727ee53f75d868be6" title="Checks whether a BDD is positive unate in a variable.">Cudd_Increasing</a> </dd></dl>

</div>
</div>
<a class="anchor" id="abe0be57ead326db49e00a51d7acf75f9"></a><!-- doxytag: member="cuddSat.c::Cudd_EqualSupNorm" ref="abe0be57ead326db49e00a51d7acf75f9" args="(DdManager *dd, DdNode *f, DdNode *g, CUDD_VALUE_TYPE tolerance, int pr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_EqualSupNorm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cudd_8h.html#a84a6539cc165870dccbd296fe29ea880">CUDD_VALUE_TYPE</a>&#160;</td>
          <td class="paramname"><em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compares two ADDs for equality within tolerance. </p>
<p>Two ADDs are reported to be equal if the maximum difference between them (the sup norm of their difference) is less than or equal to the tolerance parameter. If parameter <code>pr</code> is positive the first failure is reported to the standard output.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if the two ADDs are equal (within tolerance); 0 otherwise.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>first ADD </td></tr>
    <tr><td class="paramname">g</td><td>second ADD </td></tr>
    <tr><td class="paramname">tolerance</td><td>maximum allowed difference </td></tr>
    <tr><td class="paramname">pr</td><td>verbosity level </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3e078600dd9087c623e1bdfea00d599d"></a><!-- doxytag: member="cuddSat.c::Cudd_EquivDC" ref="a3e078600dd9087c623e1bdfea00d599d" args="(DdManager *dd, DdNode *F, DdNode *G, DdNode *D)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_EquivDC </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tells whether F and G are identical wherever D is 0. </p>
<p>F and G are either two ADDs or two BDDs. D is either a 0-1 ADD or a BDD. No new nodes are created.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if F and G are equivalent, and 0 otherwise.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddSat_8c.html#a5dcbf450b32f6937bc6dba252474638d" title="Tells whether f is less than of equal to G unless D is 1.">Cudd_bddLeqUnless</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0f11262fedecf0c0f4376432b478e6e8"></a><!-- doxytag: member="cuddSat.c::Cudd_Eval" ref="a0f11262fedecf0c0f4376432b478e6e8" args="(DdManager *dd, DdNode *f, int *inputs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_Eval </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>inputs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the value of a DD for a given variable assignment. </p>
<p>The variable assignment is passed in an array of int's, that should specify a zero or a one for each variable in the support of the function.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to a constant node. No new nodes are produced.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddBddIte_8c.html#a89a46089e8572876a1521cdee6cb31a2" title="Checks whether f is less than or equal to g.">Cudd_bddLeq</a> <a class="el" href="cuddAddIte_8c.html#a88cac595be91f0524a8be01c2b330661" title="Checks whether ADD g is constant whenever ADD f is 1.">Cudd_addEvalConst</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4f87b23df844d48727ee53f75d868be6"></a><!-- doxytag: member="cuddSat.c::Cudd_Increasing" ref="a4f87b23df844d48727ee53f75d868be6" args="(DdManager *dd, DdNode *f, int i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_Increasing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks whether a BDD is positive unate in a variable. </p>
<p>Determines whether the function represented by BDD f is positive unate (monotonic increasing) in variable i. It is based on Cudd_Decreasing and the fact that f is monotonic increasing in i if and only if its complement is monotonic decreasing in i.</p>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddSat_8c.html#a66a70b011fca8b95fbc3953e8b1be1fe" title="Checks whether a BDD is negative unate in a variable.">Cudd_Decreasing</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a5722a5bf76d99cd30783ad87ba03bf96"></a><!-- doxytag: member="cuddSat.c::Cudd_LargestCube" ref="a5722a5bf76d99cd30783ad87ba03bf96" args="(DdManager *manager, DdNode *f, int *length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_LargestCube </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finds a largest cube in a DD. </p>
<p>f is the DD we want to get the largest cube for. The problem is translated into the one of finding a shortest path in f, when both THEN and ELSE arcs are assumed to have unit length. This yields a largest cube in the disjoint cover corresponding to the DD. Therefore, it is not necessarily the largest implicant of f.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the largest cube as a BDD.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>The number of literals of the cube is returned in the location pointed by length if it is non-null.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddSat_8c.html#a78e2d36d1fdfa3d917ad345867bd4596" title="Finds a shortest path in a DD.">Cudd_ShortestPath</a> </dd></dl>

</div>
</div>
<a class="anchor" id="addfc0e508dfd1d0bd0c74104a3dd15e8"></a><!-- doxytag: member="cuddSat.c::Cudd_ShortestLength" ref="addfc0e508dfd1d0bd0c74104a3dd15e8" args="(DdManager *manager, DdNode *f, int *weight)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_ShortestLength </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>weight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the length of the shortest path(s) in a DD. </p>
<p>f is the DD we want to get the shortest path for; weight\[i\] is the weight of the THEN edge coming from the node whose index is i. All ELSE edges have 0 weight.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the length of the shortest path(s) if such a path is found; a large number if the function is identically 0, and CUDD_OUT_OF_MEM in case of failure.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddSat_8c.html#a78e2d36d1fdfa3d917ad345867bd4596" title="Finds a shortest path in a DD.">Cudd_ShortestPath</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a78e2d36d1fdfa3d917ad345867bd4596"></a><!-- doxytag: member="cuddSat.c::Cudd_ShortestPath" ref="a78e2d36d1fdfa3d917ad345867bd4596" args="(DdManager *manager, DdNode *f, int *weight, int *support, int *length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_ShortestPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>support</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finds a shortest path in a DD. </p>
<p>f is the DD we want to get the shortest path for; weight\[i\] is the weight of the THEN arc coming from the node whose index is i. If weight is NULL, then unit weights are assumed for all THEN arcs. All ELSE arcs have 0 weight. If non-NULL, both weight and support should point to arrays with at least as many entries as there are variables in the manager.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the shortest path as the BDD of a cube.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>support contains on return the true support of f. If support is NULL on entry, then Cudd_ShortestPath does not compute the true support info. length contains the length of the path.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddSat_8c.html#addfc0e508dfd1d0bd0c74104a3dd15e8" title="Find the length of the shortest path(s) in a DD.">Cudd_ShortestLength</a> <a class="el" href="cuddSat_8c.html#a5722a5bf76d99cd30783ad87ba03bf96" title="Finds a largest cube in a DD.">Cudd_LargestCube</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aad1ef5892f9b1b85a2766956fca9761c"></a><!-- doxytag: member="cuddSat.c::cuddBddMakePrime" ref="aad1ef5892f9b1b85a2766956fca9761c" args="(DdManager *dd, DdNode *cube, DdNode *f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* cuddBddMakePrime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>cube</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs the recursive step of Cudd_bddMakePrime. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the prime if successful; NULL otherwise.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">cube</td><td>cube to be expanded </td></tr>
    <tr><td class="paramname">f</td><td>function of which the cube is to be made a prime </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a68c31130d52ff1e86fbf90aa725cd95b"></a><!-- doxytag: member="cuddSat.c::ddBddMaximallyExpand" ref="a68c31130d52ff1e86fbf90aa725cd95b" args="(DdManager *dd, DdNode *lb, DdNode *ub, DdNode *f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structDdNode.html">DdNode</a>* ddBddMaximallyExpand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs the recursive step of Cudd_bddMaximallyExpand. </p>
<p>On entry to this function, ub and lb should be different from the zero BDD. The function then maintains this invariant.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>set of primes or zero BDD if successful; NULL otherwise.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None </dd></dl>

<p><p>There are three major terminal cases in theory: ub -&gt; f : return ub lb == f : return lb not(lb -&gt; f): return zero Only the second case can be checked exactly in constant time. For the others, we check for sufficient conditions.</p>
</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">lb</td><td>cube to be expanded </td></tr>
    <tr><td class="paramname">ub</td><td>upper bound cube </td></tr>
    <tr><td class="paramname">f</td><td>function against which to expand </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9c44cbf963f2d7b8989c1fbe85c37d0b"></a><!-- doxytag: member="cuddSat.c::ddBddShortestPathUnate" ref="a9c44cbf963f2d7b8989c1fbe85c37d0b" args="(DdManager *dd, DdNode *f, int *phases, st_table *table)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int ddBddShortestPathUnate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>phases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__table.html">st_table</a> *&#160;</td>
          <td class="paramname"><em>table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs shortest path computation on a unate function. </p>
<p>This function is based on the observation that in the BDD of a unate function no node except the constant is reachable from the root via paths of different parity.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the length of the shortest path to one if successful; CUDD_OUT_OF_MEM otherwise.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddSat_8c.html#a3efd005d08ed4ed56179d0f0970bb2e7" title="Finds the length of the shortest path(s) in a DD.">getShortest</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac4667addc7d0c7fa97bd42c265de96fd"></a><!-- doxytag: member="cuddSat.c::ddGetLargestCubeUnate" ref="ac4667addc7d0c7fa97bd42c265de96fd" args="(DdManager *dd, DdNode *f, int *phases, st_table *table)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structDdNode.html">DdNode</a>* ddGetLargestCubeUnate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>phases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__table.html">st_table</a> *&#160;</td>
          <td class="paramname"><em>table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extracts largest prime of a unate function. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the BDD of the prime if successful; NULL otherwise.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddSat_8c.html#aa9238a0ffa82b4ae18aec7a04ddcca24" title="Build a BDD for a shortest path of f.">getPath</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a93e5bbe63d2e2598f123244b9789a731"></a><!-- doxytag: member="cuddSat.c::freePathPair" ref="a93e5bbe63d2e2598f123244b9789a731" args="(void *key, void *value, void *arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static enum <a class="el" href="st_8h.html#a0c6a172fd99de7928916e65034ed8b1f">st_retval</a> freePathPair </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Frees the entries of the visited symbol table. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>ST_CONTINUE.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="a0b6c71713bfc3fc3e45e71f63c729c4d"></a><!-- doxytag: member="cuddSat.c::getCube" ref="a0b6c71713bfc3fc3e45e71f63c729c4d" args="(DdManager *manager, st_table *visited, DdNode *f, int cost)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structDdNode.html">DdNode</a>* getCube </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__table.html">st_table</a> *&#160;</td>
          <td class="paramname"><em>visited</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Build a BDD for a largest cube of f. </p>
<p>Given the minimum length from the root, and the minimum lengths for each node (in visited), apply triangulation at each node. Of the two children of each node on a shortest path, at least one is on a shortest path. In case of ties the procedure chooses the THEN children.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the cube BDD representing the path if successful; NULL otherwise.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="a8c6ca667c717978d9377526b5466bb24"></a><!-- doxytag: member="cuddSat.c::getLargest" ref="a8c6ca667c717978d9377526b5466bb24" args="(DdManager *dd, DdNode *root, st_table *visited)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structcuddPathPair.html">cuddPathPair</a> getLargest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__table.html">st_table</a> *&#160;</td>
          <td class="paramname"><em>visited</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finds the size of the largest cube(s) in a DD. </p>
<p>This problem is translated into finding the shortest paths from a node when both THEN and ELSE arcs have unit lengths. Uses a local symbol table to store the lengths for each node. Only the lengths for the regular nodes are entered in the table, because those for the complement nodes are simply obtained by swapping the two lenghts.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pair of lengths: the length of the shortest path to 1; and the length of the shortest path to 0. This is done so as to take complement arcs into account.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>none </dd></dl>

</div>
</div>
<a class="anchor" id="aa9238a0ffa82b4ae18aec7a04ddcca24"></a><!-- doxytag: member="cuddSat.c::getPath" ref="aa9238a0ffa82b4ae18aec7a04ddcca24" args="(DdManager *manager, st_table *visited, DdNode *f, int *weight, int cost)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structDdNode.html">DdNode</a>* getPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__table.html">st_table</a> *&#160;</td>
          <td class="paramname"><em>visited</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Build a BDD for a shortest path of f. </p>
<p>Given the minimum length from the root, and the minimum lengths for each node (in visited), apply triangulation at each node. Of the two children of each node on a shortest path, at least one is on a shortest path. In case of ties the procedure chooses the THEN children.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the cube BDD representing the path if successful; NULL otherwise.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="a3efd005d08ed4ed56179d0f0970bb2e7"></a><!-- doxytag: member="cuddSat.c::getShortest" ref="a3efd005d08ed4ed56179d0f0970bb2e7" args="(DdManager *dd, DdNode *root, int *cost, int *support, st_table *visited)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structcuddPathPair.html">cuddPathPair</a> getShortest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>cost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>support</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__table.html">st_table</a> *&#160;</td>
          <td class="paramname"><em>visited</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finds the length of the shortest path(s) in a DD. </p>
<p>Uses a local symbol table to store the lengths for each node. Only the lengths for the regular nodes are entered in the table, because those for the complement nodes are simply obtained by swapping the two lenghts.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pair of lengths: the length of the shortest path to 1; and the length of the shortest path to 0. This is done so as to take complement arcs into account.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>Accumulates the support of the DD in support. </dd></dl>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Thu May 12 2022 22:59:11 for cudd by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
