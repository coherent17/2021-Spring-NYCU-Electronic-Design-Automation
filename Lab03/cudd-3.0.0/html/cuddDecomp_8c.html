<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>cudd: cudd/cuddDecomp.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">cudd&#160;<span id="projectnumber">3.0.0</span></div>
   <div id="projectbrief">The University of Colorado Decision Diagram Package</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Defines</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>cudd/cuddDecomp.c File Reference<div class="ingroups"><a class="el" href="group__cudd.html">cudd</a></div></h1>  </div>
</div>
<div class="contents">

<p>Functions for BDD decomposition.  
<a href="#_details">More...</a></p>
<div class="textblock"><code>#include &quot;util.h&quot;</code><br/>
<code>#include &quot;<a class="el" href="cuddInt_8h_source.html">cuddInt.h</a>&quot;</code><br/>
</div><div class="textblock"><div class="dynheader">
Include dependency graph for cuddDecomp.c:</div>
<div class="dyncontent">
<div class="center"><img src="cuddDecomp_8c__incl.png" border="0" usemap="#cudd_2cuddDecomp_8c" alt=""/></div>
<map name="cudd_2cuddDecomp_8c" id="cudd_2cuddDecomp_8c">
<area shape="rect" id="node3" href="cuddInt_8h.html" title="Internal data structures of the CUDD package." alt="" coords="239,80,315,107"/><area shape="rect" id="node5" href="config_8h_source.html" title="config.h" alt="" coords="91,155,159,181"/><area shape="rect" id="node9" href="cudd_8h.html" title="The University of Colorado decision diagram package." alt="" coords="407,155,468,181"/></map>
</div>
</div><table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structConjuncts.html">Conjuncts</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a pair of conjoined BDDs.  <a href="structConjuncts.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNodeStat.html">NodeStat</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Stats for one node.  <a href="structNodeStat.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50267d552ca6f788254032e40046b770"></a><!-- doxytag: member="cuddDecomp.c::DEPTH" ref="a50267d552ca6f788254032e40046b770" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>DEPTH</b>&#160;&#160;&#160;5</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4679d8ea8690999a6c6c7c0cb245c879"></a><!-- doxytag: member="cuddDecomp.c::THRESHOLD" ref="a4679d8ea8690999a6c6c7c0cb245c879" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>THRESHOLD</b>&#160;&#160;&#160;10</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a655c84af1b0034986ff56e12e84f983d"></a><!-- doxytag: member="cuddDecomp.c::NONE" ref="a655c84af1b0034986ff56e12e84f983d" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>NONE</b>&#160;&#160;&#160;0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d0324bc023993d04644f4914ca00e99"></a><!-- doxytag: member="cuddDecomp.c::PAIR_ST" ref="a9d0324bc023993d04644f4914ca00e99" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PAIR_ST</b>&#160;&#160;&#160;1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a57e4e1e01aae91b6337bd0cf5bd5c65f"></a><!-- doxytag: member="cuddDecomp.c::PAIR_CR" ref="a57e4e1e01aae91b6337bd0cf5bd5c65f" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PAIR_CR</b>&#160;&#160;&#160;2</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4cdccfbacfcbec51d7ab394bcffb4bd6"></a><!-- doxytag: member="cuddDecomp.c::G_ST" ref="a4cdccfbacfcbec51d7ab394bcffb4bd6" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>G_ST</b>&#160;&#160;&#160;3</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1281cf32367f04a8b5d44c34d9c89302"></a><!-- doxytag: member="cuddDecomp.c::G_CR" ref="a1281cf32367f04a8b5d44c34d9c89302" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>G_CR</b>&#160;&#160;&#160;4</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a01bd6b0372e14f14782c818fbb778520"></a><!-- doxytag: member="cuddDecomp.c::H_ST" ref="a01bd6b0372e14f14782c818fbb778520" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>H_ST</b>&#160;&#160;&#160;5</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3c22a343f5591b834c0175d43bd0592b"></a><!-- doxytag: member="cuddDecomp.c::H_CR" ref="a3c22a343f5591b834c0175d43bd0592b" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>H_CR</b>&#160;&#160;&#160;6</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad4637f90ba7bba70e9644293f654c913"></a><!-- doxytag: member="cuddDecomp.c::BOTH_G" ref="ad4637f90ba7bba70e9644293f654c913" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BOTH_G</b>&#160;&#160;&#160;7</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a09f174c91e99d36c1a2ca2f683dab432"></a><!-- doxytag: member="cuddDecomp.c::BOTH_H" ref="a09f174c91e99d36c1a2ca2f683dab432" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BOTH_H</b>&#160;&#160;&#160;8</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a955ab001141d9916c63d700aafbf406a"></a><!-- doxytag: member="cuddDecomp.c::FactorsNotStored" ref="a955ab001141d9916c63d700aafbf406a" args="(factors)" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FactorsNotStored</b>(factors)&#160;&#160;&#160;((int)((<a class="el" href="cuddInt_8h.html#acaf128bda0cfdb4c18fd1553134e6840">ptrint</a>)(factors) &amp; 01))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5faf70e0ff9741c9a77b785163774a2c"></a><!-- doxytag: member="cuddDecomp.c::FactorsComplement" ref="a5faf70e0ff9741c9a77b785163774a2c" args="(factors)" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FactorsComplement</b>(factors)&#160;&#160;&#160;((<a class="el" href="structConjuncts.html">Conjuncts</a> *)((<a class="el" href="cuddInt_8h.html#acaf128bda0cfdb4c18fd1553134e6840">ptrint</a>)(factors) | 01))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2222d3e7efefe33aeb8329cfdf27cfbf"></a><!-- doxytag: member="cuddDecomp.c::FactorsUncomplement" ref="a2222d3e7efefe33aeb8329cfdf27cfbf" args="(factors)" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FactorsUncomplement</b>(factors)&#160;&#160;&#160;((<a class="el" href="structConjuncts.html">Conjuncts</a> *)((<a class="el" href="cuddInt_8h.html#acaf128bda0cfdb4c18fd1553134e6840">ptrint</a>)(factors) ^ 01))</td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac91468d32645ee617c931a873c918588"></a><!-- doxytag: member="cuddDecomp.c::Conjuncts" ref="ac91468d32645ee617c931a873c918588" args="" -->
typedef struct <a class="el" href="structConjuncts.html">Conjuncts</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddDecomp_8c.html#ac91468d32645ee617c931a873c918588">Conjuncts</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a pair of conjoined BDDs. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac127ed5f95b1fc2aea16d0ecb322798f"></a><!-- doxytag: member="cuddDecomp.c::NodeStat" ref="ac127ed5f95b1fc2aea16d0ecb322798f" args="" -->
typedef struct <a class="el" href="structNodeStat.html">NodeStat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddDecomp_8c.html#ac127ed5f95b1fc2aea16d0ecb322798f">NodeStat</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Stats for one node. <br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddDecomp_8c.html#a536e36dac9b4ddf90edb3a48934b7886">Cudd_bddApproxConjDecomp</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> ***conjuncts)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs two-way conjunctive decomposition of a BDD.  <a href="#a536e36dac9b4ddf90edb3a48934b7886"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddDecomp_8c.html#aa9d8d2d24ef2842db6b6ab5794d2bb6e">Cudd_bddApproxDisjDecomp</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> ***disjuncts)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs two-way disjunctive decomposition of a BDD.  <a href="#aa9d8d2d24ef2842db6b6ab5794d2bb6e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddDecomp_8c.html#ad7b54f1fae0417dcb3eeab6f1be792fa">Cudd_bddIterConjDecomp</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> ***conjuncts)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs two-way conjunctive decomposition of a BDD.  <a href="#ad7b54f1fae0417dcb3eeab6f1be792fa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddDecomp_8c.html#ac716bb2411a608764d34404fadf09379">Cudd_bddIterDisjDecomp</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> ***disjuncts)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs two-way disjunctive decomposition of a BDD.  <a href="#ac716bb2411a608764d34404fadf09379"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddDecomp_8c.html#a8de1749d0e92e061d1b3edafc56956b3">Cudd_bddGenConjDecomp</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> ***conjuncts)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs two-way conjunctive decomposition of a BDD.  <a href="#a8de1749d0e92e061d1b3edafc56956b3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddDecomp_8c.html#a0f7cc1a34d26e9bbf9d3919e258dd952">Cudd_bddGenDisjDecomp</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> ***disjuncts)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs two-way disjunctive decomposition of a BDD.  <a href="#a0f7cc1a34d26e9bbf9d3919e258dd952"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddDecomp_8c.html#aaa21da753c8a5798886891fed4baaaa4">Cudd_bddVarConjDecomp</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> ***conjuncts)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs two-way conjunctive decomposition of a BDD.  <a href="#aaa21da753c8a5798886891fed4baaaa4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddDecomp_8c.html#a057207ca7a87e980a040bb1183db3645">Cudd_bddVarDisjDecomp</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> ***disjuncts)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs two-way disjunctive decomposition of a BDD.  <a href="#a057207ca7a87e980a040bb1183db3645"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structNodeStat.html">NodeStat</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddDecomp_8c.html#a677a13bad737b71a8cbbf3791f0a6f9b">CreateBotDist</a> (<a class="el" href="structDdNode.html">DdNode</a> *node, <a class="el" href="structst__table.html">st_table</a> *distanceTable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get longest distance of node from constant.  <a href="#a677a13bad737b71a8cbbf3791f0a6f9b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddDecomp_8c.html#a9789f1cd2562a9398a9a8aef7fcbddac">CountMinterms</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *node, double max, <a class="el" href="structst__table.html">st_table</a> *mintermTable, FILE *fp)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of minterms of each node ina a BDD and store it in a hash table.  <a href="#a9789f1cd2562a9398a9a8aef7fcbddac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddDecomp_8c.html#af4526827b5d326a789805110e7937559">ConjunctsFree</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structConjuncts.html">Conjuncts</a> *factors)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Free factors structure.  <a href="#af4526827b5d326a789805110e7937559"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddDecomp_8c.html#a3cf0babf23592ac86844a69942f019d8">PairInTables</a> (<a class="el" href="structDdNode.html">DdNode</a> *g, <a class="el" href="structDdNode.html">DdNode</a> *h, <a class="el" href="structst__table.html">st_table</a> *ghTable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the given pair is in the tables.  <a href="#a3cf0babf23592ac86844a69942f019d8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structConjuncts.html">Conjuncts</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddDecomp_8c.html#a3774902b34268e043e475e206795736d">CheckTablesCacheAndReturn</a> (<a class="el" href="structDdManager.html">DdManager</a> *manager, <a class="el" href="structDdNode.html">DdNode</a> *node, <a class="el" href="structDdNode.html">DdNode</a> *g, <a class="el" href="structDdNode.html">DdNode</a> *h, <a class="el" href="structst__table.html">st_table</a> *ghTable, <a class="el" href="structst__table.html">st_table</a> *cacheTable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the tables for the existence of pair and return one combination, cache the result.  <a href="#a3774902b34268e043e475e206795736d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structConjuncts.html">Conjuncts</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddDecomp_8c.html#a2e65ca848499b8f665a0a94447ec406f">PickOnePair</a> (<a class="el" href="structDdManager.html">DdManager</a> *manager, <a class="el" href="structDdNode.html">DdNode</a> *node, <a class="el" href="structDdNode.html">DdNode</a> *g1, <a class="el" href="structDdNode.html">DdNode</a> *h1, <a class="el" href="structDdNode.html">DdNode</a> *g2, <a class="el" href="structDdNode.html">DdNode</a> *h2, <a class="el" href="structst__table.html">st_table</a> *ghTable, <a class="el" href="structst__table.html">st_table</a> *cacheTable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the tables for the existence of pair and return one combination, store in cache.  <a href="#a2e65ca848499b8f665a0a94447ec406f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structConjuncts.html">Conjuncts</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddDecomp_8c.html#a92fe277b7a73c473a990393fb269a508">CheckInTables</a> (<a class="el" href="structDdManager.html">DdManager</a> *manager, <a class="el" href="structDdNode.html">DdNode</a> *node, <a class="el" href="structDdNode.html">DdNode</a> *g1, <a class="el" href="structDdNode.html">DdNode</a> *h1, <a class="el" href="structDdNode.html">DdNode</a> *g2, <a class="el" href="structDdNode.html">DdNode</a> *h2, <a class="el" href="structst__table.html">st_table</a> *ghTable, <a class="el" href="structst__table.html">st_table</a> *cacheTable, int *outOfMem)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the two pairs exist in the table.  <a href="#a92fe277b7a73c473a990393fb269a508"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structConjuncts.html">Conjuncts</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddDecomp_8c.html#a4026d82c5fdbea92f4e8cda0311f2d28">ZeroCase</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *node, <a class="el" href="structConjuncts.html">Conjuncts</a> *factorsNv, <a class="el" href="structst__table.html">st_table</a> *ghTable, <a class="el" href="structst__table.html">st_table</a> *cacheTable, int switched)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">If one child is zero, do explicitly what Restrict does or better.  <a href="#a4026d82c5fdbea92f4e8cda0311f2d28"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structConjuncts.html">Conjuncts</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddDecomp_8c.html#a8fc7ad841707491ef81d19e3dbef0794">BuildConjuncts</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *node, <a class="el" href="structst__table.html">st_table</a> *distanceTable, <a class="el" href="structst__table.html">st_table</a> *cacheTable, int approxDistance, int maxLocalRef, <a class="el" href="structst__table.html">st_table</a> *ghTable, <a class="el" href="structst__table.html">st_table</a> *mintermTable, int32_t *lastTimeG)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds the conjuncts recursively, bottom up.  <a href="#a8fc7ad841707491ef81d19e3dbef0794"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddDecomp_8c.html#ad7ccdb7a449913b1e570ae336f34e665">cuddConjunctsAux</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> **c1, <a class="el" href="structDdNode.html">DdNode</a> **c2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes two conjunctive factors of f and places them in *c1 and *c2.  <a href="#ad7ccdb7a449913b1e570ae336f34e665"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Functions for BDD decomposition. </p>
<dl class="author"><dt><b>Author:</b></dt><dd>Kavita Ravi, Fabio Somenzi</dd></dl>
<p>Copyright (c) 1995-2015, Regents of the University of Colorado</p>
<p>All rights reserved.</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p>
<p>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</p>
<p>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</p>
<p>Neither the name of the University of Colorado nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</p>
<p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  </p>
</div><hr/><h2>Function Documentation</h2>
<a class="anchor" id="a8fc7ad841707491ef81d19e3dbef0794"></a><!-- doxytag: member="cuddDecomp.c::BuildConjuncts" ref="a8fc7ad841707491ef81d19e3dbef0794" args="(DdManager *dd, DdNode *node, st_table *distanceTable, st_table *cacheTable, int approxDistance, int maxLocalRef, st_table *ghTable, st_table *mintermTable, int32_t *lastTimeG)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structConjuncts.html">Conjuncts</a>* BuildConjuncts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__table.html">st_table</a> *&#160;</td>
          <td class="paramname"><em>distanceTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__table.html">st_table</a> *&#160;</td>
          <td class="paramname"><em>cacheTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>approxDistance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxLocalRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__table.html">st_table</a> *&#160;</td>
          <td class="paramname"><em>ghTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__table.html">st_table</a> *&#160;</td>
          <td class="paramname"><em>mintermTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>lastTimeG</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds the conjuncts recursively, bottom up. </p>
<p>Constants are returned as (f, f). The cache is checked for previously computed result. The decomposition points are determined by the local reference count of this node and the longest distance from the constant. At the decomposition point, the factors returned are (f, 1). Recur on the two children. The order is determined by the heavier branch. Combine the factors of the two children and pick the one that already occurs in the gh table. Occurence in g is indicated by value 1, occurence in h by 2, occurence in both by 3.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddDecomp_8c.html#ad7ccdb7a449913b1e570ae336f34e665" title="Computes two conjunctive factors of f and places them in *c1 and *c2.">cuddConjunctsAux</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a92fe277b7a73c473a990393fb269a508"></a><!-- doxytag: member="cuddDecomp.c::CheckInTables" ref="a92fe277b7a73c473a990393fb269a508" args="(DdManager *manager, DdNode *node, DdNode *g1, DdNode *h1, DdNode *g2, DdNode *h2, st_table *ghTable, st_table *cacheTable, int *outOfMem)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structConjuncts.html">Conjuncts</a>* CheckInTables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>h1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>h2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__table.html">st_table</a> *&#160;</td>
          <td class="paramname"><em>ghTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__table.html">st_table</a> *&#160;</td>
          <td class="paramname"><em>cacheTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>outOfMem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check if the two pairs exist in the table. </p>
<p>If any of the conjuncts do exist, store in the cache and return the corresponding pair.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddDecomp_8c.html#a4026d82c5fdbea92f4e8cda0311f2d28" title="If one child is zero, do explicitly what Restrict does or better.">ZeroCase</a> <a class="el" href="cuddDecomp_8c.html#a8fc7ad841707491ef81d19e3dbef0794" title="Builds the conjuncts recursively, bottom up.">BuildConjuncts</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3774902b34268e043e475e206795736d"></a><!-- doxytag: member="cuddDecomp.c::CheckTablesCacheAndReturn" ref="a3774902b34268e043e475e206795736d" args="(DdManager *manager, DdNode *node, DdNode *g, DdNode *h, st_table *ghTable, st_table *cacheTable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structConjuncts.html">Conjuncts</a>* CheckTablesCacheAndReturn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__table.html">st_table</a> *&#160;</td>
          <td class="paramname"><em>ghTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__table.html">st_table</a> *&#160;</td>
          <td class="paramname"><em>cacheTable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check the tables for the existence of pair and return one combination, cache the result. </p>
<p>The assumption is that one of the conjuncts is already in the tables.</p>
<dl class="user"><dt><b>Side effects</b></dt><dd>g and h referenced for the cache</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddDecomp_8c.html#a4026d82c5fdbea92f4e8cda0311f2d28" title="If one child is zero, do explicitly what Restrict does or better.">ZeroCase</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af4526827b5d326a789805110e7937559"></a><!-- doxytag: member="cuddDecomp.c::ConjunctsFree" ref="af4526827b5d326a789805110e7937559" args="(DdManager *dd, Conjuncts *factors)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void ConjunctsFree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structConjuncts.html">Conjuncts</a> *&#160;</td>
          <td class="paramname"><em>factors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Free factors structure. </p>
<dl class="user"><dt><b>Side effects</b></dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="a9789f1cd2562a9398a9a8aef7fcbddac"></a><!-- doxytag: member="cuddDecomp.c::CountMinterms" ref="a9789f1cd2562a9398a9a8aef7fcbddac" args="(DdManager *dd, DdNode *node, double max, st_table *mintermTable, FILE *fp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static double CountMinterms </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__table.html">st_table</a> *&#160;</td>
          <td class="paramname"><em>mintermTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Count the number of minterms of each node ina a BDD and store it in a hash table. </p>
<dl class="user"><dt><b>Side effects</b></dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="a677a13bad737b71a8cbbf3791f0a6f9b"></a><!-- doxytag: member="cuddDecomp.c::CreateBotDist" ref="a677a13bad737b71a8cbbf3791f0a6f9b" args="(DdNode *node, st_table *distanceTable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structNodeStat.html">NodeStat</a>* CreateBotDist </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__table.html">st_table</a> *&#160;</td>
          <td class="paramname"><em>distanceTable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get longest distance of node from constant. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the distance of the root from the constant if successful; CUDD_OUT_OF_MEM otherwise.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="a536e36dac9b4ddf90edb3a48934b7886"></a><!-- doxytag: member="cuddDecomp.c::Cudd_bddApproxConjDecomp" ref="a536e36dac9b4ddf90edb3a48934b7886" args="(DdManager *dd, DdNode *f, DdNode ***conjuncts)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_bddApproxConjDecomp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> ***&#160;</td>
          <td class="paramname"><em>conjuncts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs two-way conjunctive decomposition of a BDD. </p>
<p>This procedure owes its name to the use of supersetting to obtain an initial factor of the given function. The conjuncts produced by this procedure tend to be imbalanced.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of conjuncts produced, that is, 2 if successful; 1 if no meaningful decomposition was found; 0 otherwise.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>The factors are returned in an array as side effects. The array is allocated by this function. It is the caller's responsibility to free it. On successful completion, the conjuncts are already referenced. If the function returns 0, the array for the conjuncts is not allocated. If the function returns 1, the only factor equals the function to be decomposed.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddDecomp_8c.html#aa9d8d2d24ef2842db6b6ab5794d2bb6e" title="Performs two-way disjunctive decomposition of a BDD.">Cudd_bddApproxDisjDecomp</a> <a class="el" href="cuddDecomp_8c.html#ad7b54f1fae0417dcb3eeab6f1be792fa" title="Performs two-way conjunctive decomposition of a BDD.">Cudd_bddIterConjDecomp</a> <a class="el" href="cuddDecomp_8c.html#a8de1749d0e92e061d1b3edafc56956b3" title="Performs two-way conjunctive decomposition of a BDD.">Cudd_bddGenConjDecomp</a> <a class="el" href="cuddDecomp_8c.html#aaa21da753c8a5798886891fed4baaaa4" title="Performs two-way conjunctive decomposition of a BDD.">Cudd_bddVarConjDecomp</a> <a class="el" href="cuddApprox_8c.html#a88270c8ded877c10677d563b7041df38" title="Extracts a dense superset from a BDD with the remapping underapproximation method.">Cudd_RemapOverApprox</a> <a class="el" href="cuddGenCof_8c.html#afbc2329b3d7a6cb0b8adc5582fc7fe2c" title="Finds a small BDD in a function interval.">Cudd_bddSqueeze</a> <a class="el" href="cuddGenCof_8c.html#a6c23e53c189d45d06b68a9a52b724141" title="Performs safe minimization of a BDD.">Cudd_bddLICompaction</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>function to be decomposed </td></tr>
    <tr><td class="paramname">conjuncts</td><td>address of the first factor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa9d8d2d24ef2842db6b6ab5794d2bb6e"></a><!-- doxytag: member="cuddDecomp.c::Cudd_bddApproxDisjDecomp" ref="aa9d8d2d24ef2842db6b6ab5794d2bb6e" args="(DdManager *dd, DdNode *f, DdNode ***disjuncts)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_bddApproxDisjDecomp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> ***&#160;</td>
          <td class="paramname"><em>disjuncts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs two-way disjunctive decomposition of a BDD. </p>
<p>The disjuncts produced by this procedure tend to be imbalanced.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of disjuncts produced, that is, 2 if successful; 1 if no meaningful decomposition was found; 0 otherwise.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>The two disjuncts are returned in an array as side effects. The array is allocated by this function. It is the caller's responsibility to free it. On successful completion, the disjuncts are already referenced. If the function returns 0, the array for the disjuncts is not allocated. If the function returns 1, the only factor equals the function to be decomposed.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddDecomp_8c.html#a536e36dac9b4ddf90edb3a48934b7886" title="Performs two-way conjunctive decomposition of a BDD.">Cudd_bddApproxConjDecomp</a> <a class="el" href="cuddDecomp_8c.html#ac716bb2411a608764d34404fadf09379" title="Performs two-way disjunctive decomposition of a BDD.">Cudd_bddIterDisjDecomp</a> <a class="el" href="cuddDecomp_8c.html#a0f7cc1a34d26e9bbf9d3919e258dd952" title="Performs two-way disjunctive decomposition of a BDD.">Cudd_bddGenDisjDecomp</a> <a class="el" href="cuddDecomp_8c.html#a057207ca7a87e980a040bb1183db3645" title="Performs two-way disjunctive decomposition of a BDD.">Cudd_bddVarDisjDecomp</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>function to be decomposed </td></tr>
    <tr><td class="paramname">disjuncts</td><td>address of the array of the disjuncts </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8de1749d0e92e061d1b3edafc56956b3"></a><!-- doxytag: member="cuddDecomp.c::Cudd_bddGenConjDecomp" ref="a8de1749d0e92e061d1b3edafc56956b3" args="(DdManager *dd, DdNode *f, DdNode ***conjuncts)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_bddGenConjDecomp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> ***&#160;</td>
          <td class="paramname"><em>conjuncts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs two-way conjunctive decomposition of a BDD. </p>
<p>This procedure owes its name to the fact tht it generalizes the decomposition based on the cofactors with respect to one variable. The conjuncts produced by this procedure tend to be balanced.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of conjuncts produced, that is, 2 if successful; 1 if no meaningful decomposition was found; 0 otherwise.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>The two factors are returned in an array as side effects. The array is allocated by this function. It is the caller's responsibility to free it. On successful completion, the conjuncts are already referenced. If the function returns 0, the array for the conjuncts is not allocated. If the function returns 1, the only factor equals the function to be decomposed.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddDecomp_8c.html#a0f7cc1a34d26e9bbf9d3919e258dd952" title="Performs two-way disjunctive decomposition of a BDD.">Cudd_bddGenDisjDecomp</a> <a class="el" href="cuddDecomp_8c.html#a536e36dac9b4ddf90edb3a48934b7886" title="Performs two-way conjunctive decomposition of a BDD.">Cudd_bddApproxConjDecomp</a> <a class="el" href="cuddDecomp_8c.html#ad7b54f1fae0417dcb3eeab6f1be792fa" title="Performs two-way conjunctive decomposition of a BDD.">Cudd_bddIterConjDecomp</a> <a class="el" href="cuddDecomp_8c.html#aaa21da753c8a5798886891fed4baaaa4" title="Performs two-way conjunctive decomposition of a BDD.">Cudd_bddVarConjDecomp</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>function to be decomposed </td></tr>
    <tr><td class="paramname">conjuncts</td><td>address of the array of conjuncts </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0f7cc1a34d26e9bbf9d3919e258dd952"></a><!-- doxytag: member="cuddDecomp.c::Cudd_bddGenDisjDecomp" ref="a0f7cc1a34d26e9bbf9d3919e258dd952" args="(DdManager *dd, DdNode *f, DdNode ***disjuncts)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_bddGenDisjDecomp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> ***&#160;</td>
          <td class="paramname"><em>disjuncts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs two-way disjunctive decomposition of a BDD. </p>
<p>The disjuncts produced by this procedure tend to be balanced.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of disjuncts produced, that is, 2 if successful; 1 if no meaningful decomposition was found; 0 otherwise.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>The two disjuncts are returned in an array as side effects. The array is allocated by this function. It is the caller's responsibility to free it. On successful completion, the disjuncts are already referenced. If the function returns 0, the array for the disjuncts is not allocated. If the function returns 1, the only factor equals the function to be decomposed.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddDecomp_8c.html#a8de1749d0e92e061d1b3edafc56956b3" title="Performs two-way conjunctive decomposition of a BDD.">Cudd_bddGenConjDecomp</a> <a class="el" href="cuddDecomp_8c.html#aa9d8d2d24ef2842db6b6ab5794d2bb6e" title="Performs two-way disjunctive decomposition of a BDD.">Cudd_bddApproxDisjDecomp</a> <a class="el" href="cuddDecomp_8c.html#ac716bb2411a608764d34404fadf09379" title="Performs two-way disjunctive decomposition of a BDD.">Cudd_bddIterDisjDecomp</a> <a class="el" href="cuddDecomp_8c.html#a057207ca7a87e980a040bb1183db3645" title="Performs two-way disjunctive decomposition of a BDD.">Cudd_bddVarDisjDecomp</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>function to be decomposed </td></tr>
    <tr><td class="paramname">disjuncts</td><td>address of the array of the disjuncts </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad7b54f1fae0417dcb3eeab6f1be792fa"></a><!-- doxytag: member="cuddDecomp.c::Cudd_bddIterConjDecomp" ref="ad7b54f1fae0417dcb3eeab6f1be792fa" args="(DdManager *dd, DdNode *f, DdNode ***conjuncts)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_bddIterConjDecomp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> ***&#160;</td>
          <td class="paramname"><em>conjuncts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs two-way conjunctive decomposition of a BDD. </p>
<p>This procedure owes its name to the iterated use of supersetting to obtain a factor of the given function. The conjuncts produced by this procedure tend to be imbalanced.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of conjuncts produced, that is, 2 if successful; 1 if no meaningful decomposition was found; 0 otherwise.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>The factors are returned in an array as side effects. The array is allocated by this function. It is the caller's responsibility to free it. On successful completion, the conjuncts are already referenced. If the function returns 0, the array for the conjuncts is not allocated. If the function returns 1, the only factor equals the function to be decomposed.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddDecomp_8c.html#ac716bb2411a608764d34404fadf09379" title="Performs two-way disjunctive decomposition of a BDD.">Cudd_bddIterDisjDecomp</a> <a class="el" href="cuddDecomp_8c.html#a536e36dac9b4ddf90edb3a48934b7886" title="Performs two-way conjunctive decomposition of a BDD.">Cudd_bddApproxConjDecomp</a> <a class="el" href="cuddDecomp_8c.html#a8de1749d0e92e061d1b3edafc56956b3" title="Performs two-way conjunctive decomposition of a BDD.">Cudd_bddGenConjDecomp</a> <a class="el" href="cuddDecomp_8c.html#aaa21da753c8a5798886891fed4baaaa4" title="Performs two-way conjunctive decomposition of a BDD.">Cudd_bddVarConjDecomp</a> <a class="el" href="cuddApprox_8c.html#a88270c8ded877c10677d563b7041df38" title="Extracts a dense superset from a BDD with the remapping underapproximation method.">Cudd_RemapOverApprox</a> <a class="el" href="cuddGenCof_8c.html#afbc2329b3d7a6cb0b8adc5582fc7fe2c" title="Finds a small BDD in a function interval.">Cudd_bddSqueeze</a> <a class="el" href="cuddGenCof_8c.html#a6c23e53c189d45d06b68a9a52b724141" title="Performs safe minimization of a BDD.">Cudd_bddLICompaction</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>function to be decomposed </td></tr>
    <tr><td class="paramname">conjuncts</td><td>address of the array of conjuncts </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac716bb2411a608764d34404fadf09379"></a><!-- doxytag: member="cuddDecomp.c::Cudd_bddIterDisjDecomp" ref="ac716bb2411a608764d34404fadf09379" args="(DdManager *dd, DdNode *f, DdNode ***disjuncts)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_bddIterDisjDecomp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> ***&#160;</td>
          <td class="paramname"><em>disjuncts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs two-way disjunctive decomposition of a BDD. </p>
<p>The disjuncts produced by this procedure tend to be imbalanced.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of disjuncts produced, that is, 2 if successful; 1 if no meaningful decomposition was found; 0 otherwise.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>The two disjuncts are returned in an array as side effects. The array is allocated by this function. It is the caller's responsibility to free it. On successful completion, the disjuncts are already referenced. If the function returns 0, the array for the disjuncts is not allocated. If the function returns 1, the only factor equals the function to be decomposed.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddDecomp_8c.html#ad7b54f1fae0417dcb3eeab6f1be792fa" title="Performs two-way conjunctive decomposition of a BDD.">Cudd_bddIterConjDecomp</a> <a class="el" href="cuddDecomp_8c.html#aa9d8d2d24ef2842db6b6ab5794d2bb6e" title="Performs two-way disjunctive decomposition of a BDD.">Cudd_bddApproxDisjDecomp</a> <a class="el" href="cuddDecomp_8c.html#a0f7cc1a34d26e9bbf9d3919e258dd952" title="Performs two-way disjunctive decomposition of a BDD.">Cudd_bddGenDisjDecomp</a> <a class="el" href="cuddDecomp_8c.html#a057207ca7a87e980a040bb1183db3645" title="Performs two-way disjunctive decomposition of a BDD.">Cudd_bddVarDisjDecomp</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>function to be decomposed </td></tr>
    <tr><td class="paramname">disjuncts</td><td>address of the array of the disjuncts </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaa21da753c8a5798886891fed4baaaa4"></a><!-- doxytag: member="cuddDecomp.c::Cudd_bddVarConjDecomp" ref="aaa21da753c8a5798886891fed4baaaa4" args="(DdManager *dd, DdNode *f, DdNode ***conjuncts)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_bddVarConjDecomp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> ***&#160;</td>
          <td class="paramname"><em>conjuncts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs two-way conjunctive decomposition of a BDD. </p>
<p>Conjunctively decomposes one BDD according to a variable. If <code>f</code> is the function of the BDD and <code>x</code> is the variable, the decomposition is <code>(f+x)(f+x')</code>. The variable is chosen so as to balance the sizes of the two conjuncts and to keep them small.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of conjuncts produced, that is, 2 if successful; 1 if no meaningful decomposition was found; 0 otherwise.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>The two factors are returned in an array as side effects. The array is allocated by this function. It is the caller's responsibility to free it. On successful completion, the conjuncts are already referenced. If the function returns 0, the array for the conjuncts is not allocated. If the function returns 1, the only factor equals the function to be decomposed.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddDecomp_8c.html#a057207ca7a87e980a040bb1183db3645" title="Performs two-way disjunctive decomposition of a BDD.">Cudd_bddVarDisjDecomp</a> <a class="el" href="cuddDecomp_8c.html#a8de1749d0e92e061d1b3edafc56956b3" title="Performs two-way conjunctive decomposition of a BDD.">Cudd_bddGenConjDecomp</a> <a class="el" href="cuddDecomp_8c.html#a536e36dac9b4ddf90edb3a48934b7886" title="Performs two-way conjunctive decomposition of a BDD.">Cudd_bddApproxConjDecomp</a> <a class="el" href="cuddDecomp_8c.html#ad7b54f1fae0417dcb3eeab6f1be792fa" title="Performs two-way conjunctive decomposition of a BDD.">Cudd_bddIterConjDecomp</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>function to be decomposed </td></tr>
    <tr><td class="paramname">conjuncts</td><td>address of the array of conjuncts </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a057207ca7a87e980a040bb1183db3645"></a><!-- doxytag: member="cuddDecomp.c::Cudd_bddVarDisjDecomp" ref="a057207ca7a87e980a040bb1183db3645" args="(DdManager *dd, DdNode *f, DdNode ***disjuncts)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_bddVarDisjDecomp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> ***&#160;</td>
          <td class="paramname"><em>disjuncts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs two-way disjunctive decomposition of a BDD. </p>
<p>Performs two-way disjunctive decomposition of a BDD according to a variable. If <code>f</code> is the function of the BDD and <code>x</code> is the variable, the decomposition is <code>f*x + f*x'</code>. The variable is chosen so as to balance the sizes of the two disjuncts and to keep them small.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of disjuncts produced, that is, 2 if successful; 1 if no meaningful decomposition was found; 0 otherwise.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>The two disjuncts are returned in an array as side effects. The array is allocated by this function. It is the caller's responsibility to free it. On successful completion, the disjuncts are already referenced. If the function returns 0, the array for the disjuncts is not allocated. If the function returns 1, the only factor equals the function to be decomposed.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddDecomp_8c.html#aaa21da753c8a5798886891fed4baaaa4" title="Performs two-way conjunctive decomposition of a BDD.">Cudd_bddVarConjDecomp</a> <a class="el" href="cuddDecomp_8c.html#aa9d8d2d24ef2842db6b6ab5794d2bb6e" title="Performs two-way disjunctive decomposition of a BDD.">Cudd_bddApproxDisjDecomp</a> <a class="el" href="cuddDecomp_8c.html#ac716bb2411a608764d34404fadf09379" title="Performs two-way disjunctive decomposition of a BDD.">Cudd_bddIterDisjDecomp</a> <a class="el" href="cuddDecomp_8c.html#a0f7cc1a34d26e9bbf9d3919e258dd952" title="Performs two-way disjunctive decomposition of a BDD.">Cudd_bddGenDisjDecomp</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>function to be decomposed </td></tr>
    <tr><td class="paramname">disjuncts</td><td>address of the array of the disjuncts </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad7ccdb7a449913b1e570ae336f34e665"></a><!-- doxytag: member="cuddDecomp.c::cuddConjunctsAux" ref="ad7ccdb7a449913b1e570ae336f34e665" args="(DdManager *dd, DdNode *f, DdNode **c1, DdNode **c2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int cuddConjunctsAux </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>c2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes two conjunctive factors of f and places them in *c1 and *c2. </p>
<p>Sets up the required data - table of distances from the constant and local reference count. Also minterm table. </p>

</div>
</div>
<a class="anchor" id="a3cf0babf23592ac86844a69942f019d8"></a><!-- doxytag: member="cuddDecomp.c::PairInTables" ref="a3cf0babf23592ac86844a69942f019d8" args="(DdNode *g, DdNode *h, st_table *ghTable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int PairInTables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__table.html">st_table</a> *&#160;</td>
          <td class="paramname"><em>ghTable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check whether the given pair is in the tables. </p>
<p>gTable and hTable are combined. absence in both is indicated by 0, presence in gTable is indicated by 1, presence in hTable by 2 and presence in both by 3. The values returned by this function are PAIR_ST, PAIR_CR, G_ST, G_CR, H_ST, H_CR, BOTH_G, BOTH_H, NONE. PAIR_ST implies g in gTable and h in hTable PAIR_CR implies g in hTable and h in gTable G_ST implies g in gTable and h not in any table G_CR implies g in hTable and h not in any table H_ST implies h in hTable and g not in any table H_CR implies h in gTable and g not in any table BOTH_G implies both in gTable BOTH_H implies both in hTable NONE implies none in table;</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddDecomp_8c.html#a3774902b34268e043e475e206795736d" title="Check the tables for the existence of pair and return one combination, cache the result.">CheckTablesCacheAndReturn</a> <a class="el" href="cuddDecomp_8c.html#a92fe277b7a73c473a990393fb269a508" title="Check if the two pairs exist in the table.">CheckInTables</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2e65ca848499b8f665a0a94447ec406f"></a><!-- doxytag: member="cuddDecomp.c::PickOnePair" ref="a2e65ca848499b8f665a0a94447ec406f" args="(DdManager *manager, DdNode *node, DdNode *g1, DdNode *h1, DdNode *g2, DdNode *h2, st_table *ghTable, st_table *cacheTable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structConjuncts.html">Conjuncts</a>* PickOnePair </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>h1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>h2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__table.html">st_table</a> *&#160;</td>
          <td class="paramname"><em>ghTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__table.html">st_table</a> *&#160;</td>
          <td class="paramname"><em>cacheTable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check the tables for the existence of pair and return one combination, store in cache. </p>
<p>The pair that has more pointers to it is picked. An approximation of the number of local pointers is made by taking the reference count of the pairs sent.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddDecomp_8c.html#a4026d82c5fdbea92f4e8cda0311f2d28" title="If one child is zero, do explicitly what Restrict does or better.">ZeroCase</a> <a class="el" href="cuddDecomp_8c.html#a8fc7ad841707491ef81d19e3dbef0794" title="Builds the conjuncts recursively, bottom up.">BuildConjuncts</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4026d82c5fdbea92f4e8cda0311f2d28"></a><!-- doxytag: member="cuddDecomp.c::ZeroCase" ref="a4026d82c5fdbea92f4e8cda0311f2d28" args="(DdManager *dd, DdNode *node, Conjuncts *factorsNv, st_table *ghTable, st_table *cacheTable, int switched)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structConjuncts.html">Conjuncts</a>* ZeroCase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structConjuncts.html">Conjuncts</a> *&#160;</td>
          <td class="paramname"><em>factorsNv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__table.html">st_table</a> *&#160;</td>
          <td class="paramname"><em>ghTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__table.html">st_table</a> *&#160;</td>
          <td class="paramname"><em>cacheTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>switched</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If one child is zero, do explicitly what Restrict does or better. </p>
<p>First separate a variable and its child in the base case. In case of a cube times a function, separate the cube and function. As a last resort, look in tables.</p>
<dl class="user"><dt><b>Side effects</b></dt><dd>Frees the BDDs in factorsNv. factorsNv itself is not freed because it is freed above.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddDecomp_8c.html#a8fc7ad841707491ef81d19e3dbef0794" title="Builds the conjuncts recursively, bottom up.">BuildConjuncts</a> </dd></dl>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Thu May 12 2022 22:59:10 for cudd by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
