<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>cudd: st/st.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">cudd&#160;<span id="projectnumber">3.0.0</span></div>
   <div id="projectbrief">The University of Colorado Decision Diagram Package</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Defines</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>st/st.c File Reference<div class="ingroups"><a class="el" href="group__st.html">st</a></div></h1>  </div>
</div>
<div class="contents">

<p>Symbol table package.  
<a href="#_details">More...</a></p>
<div class="textblock"><code>#include &quot;util.h&quot;</code><br/>
<code>#include &quot;<a class="el" href="st_8h_source.html">st.h</a>&quot;</code><br/>
</div><div class="textblock"><div class="dynheader">
Include dependency graph for st.c:</div>
<div class="dyncontent">
<div class="center"><img src="st_8c__incl.png" border="0" usemap="#st_2st_8c" alt=""/></div>
<map name="st_2st_8c" id="st_2st_8c">
<area shape="rect" id="node3" href="st_8h.html" title="Symbol table package." alt="" coords="81,80,124,107"/></map>
</div>
</div><table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structst__table__entry.html">st_table_entry</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbol table entry.  <a href="structst__table__entry.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structst__table.html">st_table</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbol table header.  <a href="structst__table.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structst__generator.html">st_generator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbol table generator.  <a href="structst__generator.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="st_8c.html#a2796b8bc2a5f15834d61a3519ad149d5">ST_NUMCMP</a>(x, y)&#160;&#160;&#160;((x) != (y))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two numbers or two pointers.  <a href="#a2796b8bc2a5f15834d61a3519ad149d5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a76573cced143d429f99bfb5e286c621e"></a><!-- doxytag: member="st.c::ST_NUMHASH" ref="a76573cced143d429f99bfb5e286c621e" args="(x, size)" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="st_8c.html#a76573cced143d429f99bfb5e286c621e">ST_NUMHASH</a>(x, size)&#160;&#160;&#160;((int)((uintptr_t)(x)%(uintptr_t)(size)))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash function for numbers. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="st_8c.html#ab2920f4cebe075a6fda8b299fce9f762">st_shift</a>&#160;&#160;&#160;2</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Amount by which pointers should be shifted right when hashing.  <a href="#ab2920f4cebe075a6fda8b299fce9f762"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a524a1efaf5df2432aa5bf96e35546164"></a><!-- doxytag: member="st.c::ST_PTRHASH" ref="a524a1efaf5df2432aa5bf96e35546164" args="(x, size)" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="st_8c.html#a524a1efaf5df2432aa5bf96e35546164">ST_PTRHASH</a>(x, size)&#160;&#160;&#160;((int)(((uintptr_t)(x)&gt;&gt;st_shift)%(uintptr_t)(size)))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash function for pointers. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="st_8c.html#ab5676cd1fb91981de326030c5b15c867">EQUAL</a>(table, x, y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two entries.  <a href="#ab5676cd1fb91981de326030c5b15c867"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="st_8c.html#a8719b25fa2e849ad268f0bb382bae21c">do_hash</a>(key, table)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hash of one entry.  <a href="#a8719b25fa2e849ad268f0bb382bae21c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="st_8c.html#adc63a1b1f02f0b457c85154dc513d626">PTR_NOT_EQUAL</a>(table, ptr, user_key)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the new key to one in a collision list.  <a href="#adc63a1b1f02f0b457c85154dc513d626"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="st_8c.html#a9fc5c02ec598b362bd1fd5ddb6442731">FIND_ENTRY</a>(table, hash_val, key, ptr, last)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Looks up an entry in a collision list.  <a href="#a9fc5c02ec598b362bd1fd5ddb6442731"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="st_8c.html#a956d9dcd99d68ab4503789312b72c29a">ADD_DIRECT</a>(table, key, value, hash_val, newt)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an entry to a table.  <a href="#a956d9dcd99d68ab4503789312b72c29a"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4bafc81982b39c3f3fa20e5f7b3dbbf5"></a><!-- doxytag: member="st.c::st_table_entry" ref="a4bafc81982b39c3f3fa20e5f7b3dbbf5" args="" -->
typedef struct <a class="el" href="structst__table__entry.html">st_table_entry</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="st_8c.html#a4bafc81982b39c3f3fa20e5f7b3dbbf5">st_table_entry</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of symbol table entries. <br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structst__table.html">st_table</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="st_8c.html#aa2b7b77ad534ef91e00b0e6c5e73ff57">st_init_table</a> (<a class="el" href="st_8h.html#a92b54b66d65452eb05b904f136d54495">st_compare_t</a> compare, <a class="el" href="st_8h.html#a32afad795bbdad45679b4e83b65c0147">st_hash_t</a> hash)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and initializes a table.  <a href="#aa2b7b77ad534ef91e00b0e6c5e73ff57"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structst__table.html">st_table</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="st_8c.html#a8ccb3f9ea5d2c18b54ceb22f54750eb6">st_init_table_with_params</a> (<a class="el" href="st_8h.html#a92b54b66d65452eb05b904f136d54495">st_compare_t</a> compare, <a class="el" href="st_8h.html#a32afad795bbdad45679b4e83b65c0147">st_hash_t</a> hash, int size, int density, double grow_factor, int reorder_flag)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a table with given parameters.  <a href="#a8ccb3f9ea5d2c18b54ceb22f54750eb6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structst__table.html">st_table</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="st_8c.html#a4f64cd7a2c89163e347ca5120949d81c">st_init_table_with_params_and_arg</a> (<a class="el" href="st_8h.html#a31a01d9cc99837bc5004f7bdca93cd90">st_compare_arg_t</a> compare, <a class="el" href="st_8h.html#afd03ad78a25df5a4b4e74c35eb915dd9">st_hash_arg_t</a> hash, void const *arg, int size, int density, double growth_factor, int reorder_flag)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and initializes a table.  <a href="#a4f64cd7a2c89163e347ca5120949d81c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structst__table.html">st_table</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="st_8c.html#aa2b610bcb020d0fdbbaee6eb5a99f3d1">st_init_table_with_arg</a> (<a class="el" href="st_8h.html#a31a01d9cc99837bc5004f7bdca93cd90">st_compare_arg_t</a> compare, <a class="el" href="st_8h.html#afd03ad78a25df5a4b4e74c35eb915dd9">st_hash_arg_t</a> hash, void const *arg)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and initializes a table.  <a href="#aa2b610bcb020d0fdbbaee6eb5a99f3d1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="st_8c.html#a93394fd99c5fa4fbcce2be9717abee45">st_free_table</a> (<a class="el" href="structst__table.html">st_table</a> *table)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a table.  <a href="#a93394fd99c5fa4fbcce2be9717abee45"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="st_8c.html#ab31bb3faec926d5b860cce38a9a30942">st_lookup</a> (<a class="el" href="structst__table.html">st_table</a> *table, void const *key, void **value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup up `key` in `table`.  <a href="#ab31bb3faec926d5b860cce38a9a30942"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="st_8c.html#aca8c67d5af375bb4b861551e185cf7b7">st_lookup_int</a> (<a class="el" href="structst__table.html">st_table</a> *table, void const *key, int *value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup up `key` in `table`.  <a href="#aca8c67d5af375bb4b861551e185cf7b7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="st_8c.html#ac9bc9aaa7675eadf766a0a7eb5de7890">st_insert</a> (<a class="el" href="structst__table.html">st_table</a> *table, void *key, void *value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert value in `table` under the key `key`.  <a href="#ac9bc9aaa7675eadf766a0a7eb5de7890"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="st_8c.html#a18fa2f1785eb7a89b8cf437499521f73">st_add_direct</a> (<a class="el" href="structst__table.html">st_table</a> *table, void *key, void *value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Place 'value' in 'table' under the key 'key'.  <a href="#a18fa2f1785eb7a89b8cf437499521f73"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="st_8c.html#a65bba661da8b8cf27afd6cba9119e28a">st_find_or_add</a> (<a class="el" href="structst__table.html">st_table</a> *table, void *key, void ***slot)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup `key` in `table`; if not found, create an entry.  <a href="#a65bba661da8b8cf27afd6cba9119e28a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="st_8c.html#a2e63dc98d33d74e04354141ff193b49d">st_find</a> (<a class="el" href="structst__table.html">st_table</a> *table, void const *key, void ***slot)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup `key` in `table`.  <a href="#a2e63dc98d33d74e04354141ff193b49d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structst__table.html">st_table</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="st_8c.html#a93884b823743f324d9cea4d68419cf9d">st_copy</a> (<a class="el" href="structst__table.html">st_table</a> const *old_table)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of old_table and all its members.  <a href="#a93884b823743f324d9cea4d68419cf9d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="st_8c.html#a4a96b50ff14befd418c6f4b047b7674e">st_delete</a> (<a class="el" href="structst__table.html">st_table</a> *table, void **keyp, void **value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the entry with the key pointed to by `keyp`.  <a href="#a4a96b50ff14befd418c6f4b047b7674e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="st_8c.html#a048a0d1575248c3efbb57785a034b699">st_delete_int</a> (<a class="el" href="structst__table.html">st_table</a> *table, void **keyp, int *value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the entry with the key pointed to by `keyp`.  <a href="#a048a0d1575248c3efbb57785a034b699"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="st_8c.html#a0b4aa16f307eb2a1ac85c47b23986da5">st_count</a> (<a class="el" href="structst__table.html">st_table</a> const *table)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of entries in the table `table`.  <a href="#a0b4aa16f307eb2a1ac85c47b23986da5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="st_8c.html#ab518bee88ffd40540bcef1f71cff2cd4">st_foreach</a> (<a class="el" href="structst__table.html">st_table</a> *table, <a class="el" href="st_8h.html#afce858d892e82832d6a44695f73752a3">st_foreach_t</a> func, void *arg)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterates over the elements of a table.  <a href="#ab518bee88ffd40540bcef1f71cff2cd4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="st_8c.html#ae04fa098acd6e45c99d7a5fca22757c4">st_strhash</a> (void const *string, int modulus)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">String hash function.  <a href="#ae04fa098acd6e45c99d7a5fca22757c4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="st_8c.html#a68825c6bc096e1c070c201b682d5c5ae">st_numhash</a> (void const *x, int size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Integral number hash function.  <a href="#a68825c6bc096e1c070c201b682d5c5ae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="st_8c.html#a60ac0bfd65626294270cf1170c901563">st_ptrhash</a> (void const *x, int size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer hash function.  <a href="#a60ac0bfd65626294270cf1170c901563"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="st_8c.html#a9cbfe1d326096178ff0a7f429dff5447">st_numcmp</a> (void const *x, void const *y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Integral number comparison function.  <a href="#a9cbfe1d326096178ff0a7f429dff5447"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="st_8c.html#a498b5be01ce89910cfc8d3d95d68032c">st_ptrcmp</a> (void const *x, void const *y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer comparison function.  <a href="#a498b5be01ce89910cfc8d3d95d68032c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structst__generator.html">st_generator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="st_8c.html#a6d0cf6e8f43a92793be9c1880e40283e">st_init_gen</a> (<a class="el" href="structst__table.html">st_table</a> const *table)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a generator.  <a href="#a6d0cf6e8f43a92793be9c1880e40283e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="st_8c.html#a74246992b0cf18b6c0c26cd2642bd774">st_gen</a> (<a class="el" href="structst__generator.html">st_generator</a> *gen, void **key_p, void **value_p)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the next (key, value) pair in the generation sequence.  <a href="#a74246992b0cf18b6c0c26cd2642bd774"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="st_8c.html#a51bda91f156077094cf0ee4b4e06d092">st_gen_int</a> (<a class="el" href="structst__generator.html">st_generator</a> *gen, void **key_p, int *value_p)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the next (key, value) pair in the generation sequence.  <a href="#a51bda91f156077094cf0ee4b4e06d092"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="st_8c.html#ad41b7ddada4e857c815181e0da79c8e1">st_free_gen</a> (<a class="el" href="structst__generator.html">st_generator</a> *gen)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reclaims the resources associated with `gen`.  <a href="#ad41b7ddada4e857c815181e0da79c8e1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="st_8c.html#a974179f1640bb047e2c46bdafe2b2fb0">rehash</a> (<a class="el" href="structst__table.html">st_table</a> *table)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Rehashes a symbol table.  <a href="#a974179f1640bb047e2c46bdafe2b2fb0"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Symbol table package. </p>
<p>The st library provides functions to create, maintain, and query symbol tables.</p>
<p>Copyright (c) 1994-1998 The Regents of the Univ. of California. All rights reserved.</p>
<p>Permission is hereby granted, without written agreement and without license or royalty fees, to use, copy, modify, and distribute this software and its documentation for any purpose, provided that the above copyright notice and the following two paragraphs appear in all copies of this software.</p>
<p>IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<p>THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. </p>
<p>Copyright (c) 1999-2015, Regents of the University of Colorado</p>
<p>All rights reserved.</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p>
<p>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</p>
<p>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</p>
<p>Neither the name of the University of Colorado nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</p>
<p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  </p>
</div><hr/><h2>Define Documentation</h2>
<a class="anchor" id="a956d9dcd99d68ab4503789312b72c29a"></a><!-- doxytag: member="st.c::ADD_DIRECT" ref="a956d9dcd99d68ab4503789312b72c29a" args="(table, key, value, hash_val, newt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADD_DIRECT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">table, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">value, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">hash_val, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">newt&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">{\
    <span class="keywordflow">if</span> (table-&gt;num_entries/table-&gt;num_bins &gt;= table-&gt;max_density) {\
    <a class="code" href="st_8c.html#a974179f1640bb047e2c46bdafe2b2fb0" title="Rehashes a symbol table.">rehash</a>(table);\
    hash_val = <a class="code" href="st_8c.html#a8719b25fa2e849ad268f0bb382bae21c" title="Computes the hash of one entry.">do_hash</a>(key,table);\
    }\
    \
    newt = <a class="code" href="util_8h.html#a21755cdb11c76954a33c653579810f3a" title="Wrapper for either malloc or MMalloc.">ALLOC</a>(<a class="code" href="structst__table__entry.html" title="Symbol table entry.">st_table_entry</a>, 1);\
    \
    newt-&gt;key = key;\
    newt-&gt;record = value;\
    newt-&gt;next = table-&gt;bins[hash_val];\
    table-&gt;bins[hash_val] = newt;\
    table-&gt;num_entries++;\
}
</pre></div>
<p>Adds an entry to a table. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>This macro does not check if memory allocation fails. Use at your own risk. </dd></dl>

</div>
</div>
<a class="anchor" id="a8719b25fa2e849ad268f0bb382bae21c"></a><!-- doxytag: member="st.c::do_hash" ref="a8719b25fa2e849ad268f0bb382bae21c" args="(key, table)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define do_hash</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">table&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">(((table)-&gt;hash == <a class="code" href="st_8c.html#a60ac0bfd65626294270cf1170c901563" title="Pointer hash function.">st_ptrhash</a>) ? <a class="code" href="st_8c.html#a524a1efaf5df2432aa5bf96e35546164" title="Hash function for pointers.">ST_PTRHASH</a>((key), (table)-&gt;num_bins) : \
     ((table)-&gt;hash == <a class="code" href="st_8c.html#a68825c6bc096e1c070c201b682d5c5ae" title="Integral number hash function.">st_numhash</a>) ? <a class="code" href="st_8c.html#a76573cced143d429f99bfb5e286c621e" title="Hash function for numbers.">ST_NUMHASH</a>((key), (table)-&gt;num_bins) : \
     ((table)-&gt;hash) ? (*(table)-&gt;hash)((key), (table)-&gt;num_bins) : \
     (*(table)-&gt;hash_arg)((key), (table)-&gt;num_bins, (table)-&gt;arg))
</pre></div>
<p>Computes the hash of one entry. </p>

</div>
</div>
<a class="anchor" id="ab5676cd1fb91981de326030c5b15c867"></a><!-- doxytag: member="st.c::EQUAL" ref="ab5676cd1fb91981de326030c5b15c867" args="(table, x, y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EQUAL</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">table, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">y&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">((((table)-&gt;compare == <a class="code" href="st_8c.html#a9cbfe1d326096178ff0a7f429dff5447" title="Integral number comparison function.">st_numcmp</a>) || ((table)-&gt;compare == <a class="code" href="st_8c.html#a498b5be01ce89910cfc8d3d95d68032c" title="Pointer comparison function.">st_ptrcmp</a>)) ?\
     (<a class="code" href="st_8c.html#a2796b8bc2a5f15834d61a3519ad149d5" title="Compares two numbers or two pointers.">ST_NUMCMP</a>((x),(y)) == 0) : ((table)-&gt;compare) ?\
     ((*(table)-&gt;compare)((x), (y)) == 0) :\
     ((*(table)-&gt;compare_arg)((x), (y), (table)-&gt;arg) == 0))
</pre></div>
<p>Compares two entries. </p>

</div>
</div>
<a class="anchor" id="a9fc5c02ec598b362bd1fd5ddb6442731"></a><!-- doxytag: member="st.c::FIND_ENTRY" ref="a9fc5c02ec598b362bd1fd5ddb6442731" args="(table, hash_val, key, ptr, last)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FIND_ENTRY</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">table, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">hash_val, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">last&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">(last) = &amp;(table)-&gt;bins[hash_val];\
    (ptr) = *(last);\
    <span class="keywordflow">while</span> (<a class="code" href="st_8c.html#adc63a1b1f02f0b457c85154dc513d626" title="Compares the new key to one in a collision list.">PTR_NOT_EQUAL</a>((table), (ptr), (key))) {\
    (last) = &amp;(ptr)-&gt;next; (ptr) = *(last);\
    }\
    <span class="keywordflow">if</span> ((ptr) != <a class="code" href="util_8h.html#a31bfee01545b78af63301bf9e857218b" title="Type-decorated NULL (for documentation).">NIL</a>(<a class="code" href="structst__table__entry.html" title="Symbol table entry.">st_table_entry</a>) &amp;&amp; (table)-&gt;reorder_flag) {\
    *(last) = (ptr)-&gt;next;\
    (ptr)-&gt;next = (table)-&gt;bins[hash_val];\
    (table)-&gt;bins[hash_val] = (ptr);\
    }
</pre></div>
<p>Looks up an entry in a collision list. </p>
<p>If the entry is found and the reorder flag is set, the found entry is brought to the fore of the collision list. </p>

</div>
</div>
<a class="anchor" id="adc63a1b1f02f0b457c85154dc513d626"></a><!-- doxytag: member="st.c::PTR_NOT_EQUAL" ref="adc63a1b1f02f0b457c85154dc513d626" args="(table, ptr, user_key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PTR_NOT_EQUAL</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">table, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">user_key&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">((ptr) != <a class="code" href="util_8h.html#a31bfee01545b78af63301bf9e857218b" title="Type-decorated NULL (for documentation).">NIL</a>(<a class="code" href="structst__table__entry.html" title="Symbol table entry.">st_table_entry</a>) &amp;&amp; \
     !<a class="code" href="st_8c.html#ab5676cd1fb91981de326030c5b15c867" title="Compares two entries.">EQUAL</a>((table), (user_key), (ptr)-&gt;key))
</pre></div>
<p>Compares the new key to one in a collision list. </p>

</div>
</div>
<a class="anchor" id="a2796b8bc2a5f15834d61a3519ad149d5"></a><!-- doxytag: member="st.c::ST_NUMCMP" ref="a2796b8bc2a5f15834d61a3519ad149d5" args="(x, y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ST_NUMCMP</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">y&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((x) != (y))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compares two numbers or two pointers. </p>
<p>Used by the default comparison functions. </p>

</div>
</div>
<a class="anchor" id="ab2920f4cebe075a6fda8b299fce9f762"></a><!-- doxytag: member="st.c::st_shift" ref="ab2920f4cebe075a6fda8b299fce9f762" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define st_shift&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Amount by which pointers should be shifted right when hashing. </p>
<p>This is to discard bits that are (likely to be) 0 due to alignment constraints. </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a974179f1640bb047e2c46bdafe2b2fb0"></a><!-- doxytag: member="st.c::rehash" ref="a974179f1640bb047e2c46bdafe2b2fb0" args="(st_table *table)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int rehash </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__table.html">st_table</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rehashes a symbol table. </p>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="st_8h.html#aca243196fa4ab979ccdd33888fdfcacf" title="Insert value in `table` under the key `key`.">st_insert</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a18fa2f1785eb7a89b8cf437499521f73"></a><!-- doxytag: member="st.c::st_add_direct" ref="a18fa2f1785eb7a89b8cf437499521f73" args="(st_table *table, void *key, void *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int st_add_direct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__table.html">st_table</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Place 'value' in 'table' under the key 'key'. </p>
<p>This is done without checking if 'key' is in 'table' already. This should only be used if you are sure there is not already an entry for 'key', since it is undefined which entry you would later get from st_lookup or st_find_or_add.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if successful; ST_OUT_OF_MEM otherwise.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="st_8h.html#a3386ecb50e8ec0ab4b0147d9816dd70f" title="Lookup up `key` in `table`.">st_lookup</a> <a class="el" href="st_8h.html#af56631e38efcf9ee319e5ab24b4e52d4" title="Lookup `key` in `table`; if not found, create an entry.">st_find_or_add</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a93884b823743f324d9cea4d68419cf9d"></a><!-- doxytag: member="st.c::st_copy" ref="a93884b823743f324d9cea4d68419cf9d" args="(st_table const *old_table)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structst__table.html">st_table</a>* st_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__table.html">st_table</a> const *&#160;</td>
          <td class="paramname"><em>old_table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a copy of old_table and all its members. </p>
<p>(<a class="el" href="structst__table.html" title="Symbol table header.">st_table</a> *) 0 is returned if there was insufficient memory to do the copy.</p>
<dl class="user"><dt><b>Side effects</b></dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="a0b4aa16f307eb2a1ac85c47b23986da5"></a><!-- doxytag: member="st.c::st_count" ref="a0b4aa16f307eb2a1ac85c47b23986da5" args="(st_table const *table)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int st_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__table.html">st_table</a> const *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the number of entries in the table `table`. </p>
<dl class="user"><dt><b>Side effects</b></dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="a4a96b50ff14befd418c6f4b047b7674e"></a><!-- doxytag: member="st.c::st_delete" ref="a4a96b50ff14befd418c6f4b047b7674e" args="(st_table *table, void **keyp, void **value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int st_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__table.html">st_table</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>keyp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deletes the entry with the key pointed to by `keyp`. </p>
<p>If the entry is found, 1 is returned, the variable pointed by `keyp` is set to the actual key and the variable pointed by `value` is set to the corresponding entry. (This allows the freeing of the associated storage.) If the entry is not found, then 0 is returned and nothing is changed.</p>
<dl class="user"><dt><b>Side effects</b></dt><dd>The locations pointed by keyp and value are modified.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="st_8h.html#a52fb2ca6cd34645d22d0799e2a6a3b4d" title="Deletes the entry with the key pointed to by `keyp`.">st_delete_int</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a048a0d1575248c3efbb57785a034b699"></a><!-- doxytag: member="st.c::st_delete_int" ref="a048a0d1575248c3efbb57785a034b699" args="(st_table *table, void **keyp, int *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int st_delete_int </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__table.html">st_table</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>keyp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deletes the entry with the key pointed to by `keyp`. </p>
<p>`value` must be a pointer to an integer. If the entry is found, 1 is returned, the variable pointed by `keyp` is set to the actual key and the variable pointed by `value` is set to the corresponding entry. (This allows the freeing of the associated storage.) If the entry is not found, then 0 is returned and nothing is changed.</p>
<dl class="user"><dt><b>Side effects</b></dt><dd>The locations pointed by keyp and value are modified.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="st_8h.html#ae784cc3b55db03cc6586fc14ab7458ab" title="Deletes the entry with the key pointed to by `keyp`.">st_delete</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2e63dc98d33d74e04354141ff193b49d"></a><!-- doxytag: member="st.c::st_find" ref="a2e63dc98d33d74e04354141ff193b49d" args="(st_table *table, void const *key, void ***slot)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int st_find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__table.html">st_table</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void ***&#160;</td>
          <td class="paramname"><em>slot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Lookup `key` in `table`. </p>
<p>Like st_find_or_add, but does not create an entry if one is not found.</p>
<dl class="user"><dt><b>Side effects</b></dt><dd>The location pointed by slot is modified.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="st_8h.html#af56631e38efcf9ee319e5ab24b4e52d4" title="Lookup `key` in `table`; if not found, create an entry.">st_find_or_add</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a65bba661da8b8cf27afd6cba9119e28a"></a><!-- doxytag: member="st.c::st_find_or_add" ref="a65bba661da8b8cf27afd6cba9119e28a" args="(st_table *table, void *key, void ***slot)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int st_find_or_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__table.html">st_table</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void ***&#160;</td>
          <td class="paramname"><em>slot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Lookup `key` in `table`; if not found, create an entry. </p>
<p>In either case set slot to point to the field in the entry where the value is stored. The value associated with `key` may then be changed by accessing directly through slot. As an example:</p>
<p>void **slot; void *key; void *value = item_ptr // ptr to a malloc'd structure</p>
<p>if (st_find_or_add(table, key, &amp;slot) == 1) { <a class="el" href="util_8h.html#aa279a8302d25fa9dfeb3e00161aee784" title="Wrapper for free.">FREE(*slot)</a>; // free the old value of the record } slot = value; // attach the new value to the record</p>
<p>This replaces the equivelent code:</p>
<p>if (st_lookup(table, key, &amp;ovalue) == 1) { <a class="el" href="util_8h.html#aa279a8302d25fa9dfeb3e00161aee784" title="Wrapper for free.">FREE(ovalue)</a>; } st_insert(table, key, value);</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if an entry already existed, 0 if it did not exist and creation was successful; ST_OUT_OF_MEM otherwise.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>The location pointed by slot is modified.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="st_8h.html#a0bbf99b0b10b904e70d6452523ffb9e9" title="Lookup `key` in `table`.">st_find</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab518bee88ffd40540bcef1f71cff2cd4"></a><!-- doxytag: member="st.c::st_foreach" ref="ab518bee88ffd40540bcef1f71cff2cd4" args="(st_table *table, st_foreach_t func, void *arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int st_foreach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__table.html">st_table</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="st_8h.html#afce858d892e82832d6a44695f73752a3">st_foreach_t</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Iterates over the elements of a table. </p>
<p>For each (key, value) record in `table`, st_foreach calls func with the arguments</p>
<p>(*func)(key, value, arg)</p>
<p>If func returns ST_CONTINUE, st_foreach continues processing entries. If func returns ST_STOP, st_foreach stops processing and returns immediately. If func returns ST_DELETE, then the entry is deleted from the symbol table and st_foreach continues. In the case of ST_DELETE, it is func's responsibility to free the key and value, if necessary. The order in which the records are visited will be seemingly random.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if all items in the table were generated and 0 if the generation sequence was aborted using ST_STOP.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="st_8h.html#aea51027ca2b7197709990fb086e12c2c" title="Iteration macro.">st_foreach_item</a> <a class="el" href="st_8h.html#a437227772bc9c4c0ec636f5723654a4c" title="Iteration macro.">st_foreach_item_int</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad41b7ddada4e857c815181e0da79c8e1"></a><!-- doxytag: member="st.c::st_free_gen" ref="ad41b7ddada4e857c815181e0da79c8e1" args="(st_generator *gen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void st_free_gen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__generator.html">st_generator</a> *&#160;</td>
          <td class="paramname"><em>gen</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reclaims the resources associated with `gen`. </p>
<p>After generating all items in a generation sequence, this routine must be called to reclaim the resources associated with `gen`.</p>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="st_8h.html#a79edf5795705c813026b86a797902815" title="Initializes a generator.">st_init_gen</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a93394fd99c5fa4fbcce2be9717abee45"></a><!-- doxytag: member="st.c::st_free_table" ref="a93394fd99c5fa4fbcce2be9717abee45" args="(st_table *table)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void st_free_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__table.html">st_table</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Free a table. </p>
<p>Any internal storage associated with table is freed. It is the user's responsibility to free any storage associated with the pointers he placed in the table (by perhaps using st_foreach).</p>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="st_8h.html#a243e6ea7c74f6a18e2de12f2cf4114ef" title="Creates and initializes a table.">st_init_table</a> <a class="el" href="st_8h.html#a84ae3fc3281406cf6cb8902b4d6ed40d" title="Create a table with given parameters.">st_init_table_with_params</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a74246992b0cf18b6c0c26cd2642bd774"></a><!-- doxytag: member="st.c::st_gen" ref="a74246992b0cf18b6c0c26cd2642bd774" args="(st_generator *gen, void **key_p, void **value_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int st_gen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__generator.html">st_generator</a> *&#160;</td>
          <td class="paramname"><em>gen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>key_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>value_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the next (key, value) pair in the generation sequence. </p>
<p>Given a generator returned by <a class="el" href="st_8c.html#a6d0cf6e8f43a92793be9c1880e40283e" title="Initializes a generator.">st_init_gen()</a>, this routine returns the next (key, value) pair in the generation sequence. The pointer `value_p` can be zero which means no value will be returned. When there are no more items in the generation sequence, the routine returns 0.</p>
<p>While using a generation sequence, deleting any (key, value) pair other than the one just generated may cause a fatal error when <a class="el" href="st_8c.html#a74246992b0cf18b6c0c26cd2642bd774" title="Returns the next (key, value) pair in the generation sequence.">st_gen()</a> is called later in the sequence and is therefore not recommended. </p>
<dl class="user"><dt><b>Side effects</b></dt><dd>The locations pointed by key_p and value_p are modified.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="st_8h.html#a5f81b87e82f3330f31d7b96258d651d3" title="Returns the next (key, value) pair in the generation sequence.">st_gen_int</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a51bda91f156077094cf0ee4b4e06d092"></a><!-- doxytag: member="st.c::st_gen_int" ref="a51bda91f156077094cf0ee4b4e06d092" args="(st_generator *gen, void **key_p, int *value_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int st_gen_int </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__generator.html">st_generator</a> *&#160;</td>
          <td class="paramname"><em>gen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>key_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>value_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the next (key, value) pair in the generation sequence. </p>
<p>Given a generator returned by <a class="el" href="st_8c.html#a6d0cf6e8f43a92793be9c1880e40283e" title="Initializes a generator.">st_init_gen()</a>, this routine returns the next (key, value) pair in the generation sequence. `value_p` must be a pointer to an integer. The pointer `value_p` can be zero which means no value will be returned. When there are no more items in the generation sequence, the routine returns 0.</p>
<dl class="user"><dt><b>Side effects</b></dt><dd>The locations pointed by key_p and value_p are modified.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="st_8h.html#ab16eebebff7ee545c93d770dabbb6db8" title="Returns the next (key, value) pair in the generation sequence.">st_gen</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6d0cf6e8f43a92793be9c1880e40283e"></a><!-- doxytag: member="st.c::st_init_gen" ref="a6d0cf6e8f43a92793be9c1880e40283e" args="(st_table const *table)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structst__generator.html">st_generator</a>* st_init_gen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__table.html">st_table</a> const *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initializes a generator. </p>
<p>Returns a generator handle which when used with <a class="el" href="st_8c.html#a74246992b0cf18b6c0c26cd2642bd774" title="Returns the next (key, value) pair in the generation sequence.">st_gen()</a> will progressively return each (key, value) record in `table`.</p>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="st_8h.html#a819c7d22d51c5f7e26fc1fc7038b0daf" title="Reclaims the resources associated with `gen`.">st_free_gen</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa2b7b77ad534ef91e00b0e6c5e73ff57"></a><!-- doxytag: member="st.c::st_init_table" ref="aa2b7b77ad534ef91e00b0e6c5e73ff57" args="(st_compare_t compare, st_hash_t hash)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structst__table.html">st_table</a>* st_init_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="st_8h.html#a92b54b66d65452eb05b904f136d54495">st_compare_t</a>&#160;</td>
          <td class="paramname"><em>compare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="st_8h.html#a32afad795bbdad45679b4e83b65c0147">st_hash_t</a>&#160;</td>
          <td class="paramname"><em>hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates and initializes a table. </p>
<p>Creates and initializes a table with the comparison function compare_fn and hash function hash_fn. compare_fn is</p>
<p>int compare_fn(const void *key1, const void *key2)</p>
<p>It returns `&lt;,=,&gt; 0` depending on whether `key1 &lt;,=,&gt; key2` by some measure.</p>
<p>hash_fn is</p>
<p>int hash_fn(void *key, int modulus)</p>
<p>It returns an integer between `0` and `modulus-1` such that if `compare_fn(key1,key2) == 0` then `hash_fn(key1) == hash_fn(key2)`.</p>
<p>There are five predefined hash and comparison functions in st. For keys as numbers:</p>
<p>st_numhash(key, modulus) { return (unsigned int) key % modulus; } st_numcmp(x,y) { return (int) x - (int) y; }</p>
<p>For keys as pointers:</p>
<p>st_ptrhash(key, modulus) { return ((unsigned int) key/4) % modulus } st_ptrcmp(x,y) { return (int) x - (int) y; }</p>
<p>For keys as strings:</p>
<p>st_strhash(x,y) - a reasonable hashing function for strings strcmp(x,y) - the standard library function</p>
<p>It is recommended to use these particular functions if they fit your needs, since st will recognize certain of them and run more quickly because of it.</p>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="st_8h.html#a84ae3fc3281406cf6cb8902b4d6ed40d" title="Create a table with given parameters.">st_init_table_with_params</a> <a class="el" href="st_8h.html#acb004847ef312373d65bfb0d1a21c5b3" title="Free a table.">st_free_table</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa2b610bcb020d0fdbbaee6eb5a99f3d1"></a><!-- doxytag: member="st.c::st_init_table_with_arg" ref="aa2b610bcb020d0fdbbaee6eb5a99f3d1" args="(st_compare_arg_t compare, st_hash_arg_t hash, void const *arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structst__table.html">st_table</a>* st_init_table_with_arg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="st_8h.html#a31a01d9cc99837bc5004f7bdca93cd90">st_compare_arg_t</a>&#160;</td>
          <td class="paramname"><em>compare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="st_8h.html#afd03ad78a25df5a4b4e74c35eb915dd9">st_hash_arg_t</a>&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates and initializes a table. </p>
<p>Like st_init_table, but the comparison and hash functions are passed an extra parameter `arg` that is registered in the table at initialization.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="st_8h.html#a243e6ea7c74f6a18e2de12f2cf4114ef" title="Creates and initializes a table.">st_init_table</a> <a class="el" href="st_8h.html#a3ca92268a0d9cbbe7636763ca628abb0" title="Creates and initializes a table.">st_init_table_with_params_and_arg</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8ccb3f9ea5d2c18b54ceb22f54750eb6"></a><!-- doxytag: member="st.c::st_init_table_with_params" ref="a8ccb3f9ea5d2c18b54ceb22f54750eb6" args="(st_compare_t compare, st_hash_t hash, int size, int density, double grow_factor, int reorder_flag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structst__table.html">st_table</a>* st_init_table_with_params </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="st_8h.html#a92b54b66d65452eb05b904f136d54495">st_compare_t</a>&#160;</td>
          <td class="paramname"><em>compare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="st_8h.html#a32afad795bbdad45679b4e83b65c0147">st_hash_t</a>&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>density</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>grow_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>reorder_flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a table with given parameters. </p>
<p>The full blown table initializer. compare and hash are the same as in st_init_table. density is the largest the average number of entries per hash bin there should be before the table is grown. grow_factor is the factor the table is grown by when it becomes too full. size is the initial number of bins to be allocated for the hash table. If reorder_flag is non-zero, then every time an entry is found, it is moved to the top of the chain.</p>
<p>st_init_table(compare, hash) is equivelent to</p>
<p>st_init_table_with_params(compare, hash, ST_DEFAULT_INIT_TABLE_SIZE, ST_DEFAULT_MAX_DENSITY, ST_DEFAULT_GROW_FACTOR, ST_DEFAULT_REORDER_FLAG);</p>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="st_8h.html#a243e6ea7c74f6a18e2de12f2cf4114ef" title="Creates and initializes a table.">st_init_table</a> <a class="el" href="st_8h.html#acb004847ef312373d65bfb0d1a21c5b3" title="Free a table.">st_free_table</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4f64cd7a2c89163e347ca5120949d81c"></a><!-- doxytag: member="st.c::st_init_table_with_params_and_arg" ref="a4f64cd7a2c89163e347ca5120949d81c" args="(st_compare_arg_t compare, st_hash_arg_t hash, void const *arg, int size, int density, double growth_factor, int reorder_flag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structst__table.html">st_table</a>* st_init_table_with_params_and_arg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="st_8h.html#a31a01d9cc99837bc5004f7bdca93cd90">st_compare_arg_t</a>&#160;</td>
          <td class="paramname"><em>compare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="st_8h.html#afd03ad78a25df5a4b4e74c35eb915dd9">st_hash_arg_t</a>&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>density</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>growth_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>reorder_flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates and initializes a table. </p>
<p>Like st_init_table_with_params, but the comparison and hash functions are passed an extra parameter `arg` that is registered in the table at initialization.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="st_8h.html#a84ae3fc3281406cf6cb8902b4d6ed40d" title="Create a table with given parameters.">st_init_table_with_params</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac9bc9aaa7675eadf766a0a7eb5de7890"></a><!-- doxytag: member="st.c::st_insert" ref="ac9bc9aaa7675eadf766a0a7eb5de7890" args="(st_table *table, void *key, void *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int st_insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__table.html">st_table</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert value in `table` under the key `key`. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if there was an entry already under the key; 0 if there was no entry under the key and insertion was successful; ST_OUT_OF_MEM otherwise. In either of the first two cases the new value is added.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ab31bb3faec926d5b860cce38a9a30942"></a><!-- doxytag: member="st.c::st_lookup" ref="ab31bb3faec926d5b860cce38a9a30942" args="(st_table *table, void const *key, void **value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int st_lookup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__table.html">st_table</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Lookup up `key` in `table`. </p>
<p>If an entry is found, 1 is returned and if `value` is not nil, the variable it points to is set to the associated value. If an entry is not found, 0 is returned and the variable pointed by value is unchanged.</p>
<dl class="user"><dt><b>Side effects</b></dt><dd>The location pointed by value is modified.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="st_8h.html#a68968aaa1c2b612c3f8e0d2961f08987" title="Lookup up `key` in `table`.">st_lookup_int</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aca8c67d5af375bb4b861551e185cf7b7"></a><!-- doxytag: member="st.c::st_lookup_int" ref="aca8c67d5af375bb4b861551e185cf7b7" args="(st_table *table, void const *key, int *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int st_lookup_int </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__table.html">st_table</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Lookup up `key` in `table`. </p>
<p>If an entry is found, 1 is returned and if `value` is not nil, the variable it points to is set to the associated integer value. If an entry is not found, 0 is return and the variable pointed by `value` is unchanged.</p>
<dl class="user"><dt><b>Side effects</b></dt><dd>The location pointed by value is modified.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="st_8h.html#a3386ecb50e8ec0ab4b0147d9816dd70f" title="Lookup up `key` in `table`.">st_lookup</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9cbfe1d326096178ff0a7f429dff5447"></a><!-- doxytag: member="st.c::st_numcmp" ref="a9cbfe1d326096178ff0a7f429dff5447" args="(void const *x, void const *y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int st_numcmp </td>
          <td>(</td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Integral number comparison function. </p>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="st_8h.html#a243e6ea7c74f6a18e2de12f2cf4114ef" title="Creates and initializes a table.">st_init_table</a> <a class="el" href="st_8h.html#acd937a251f8fd422563e708fbbf70ed5" title="Integral number hash function.">st_numhash</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a68825c6bc096e1c070c201b682d5c5ae"></a><!-- doxytag: member="st.c::st_numhash" ref="a68825c6bc096e1c070c201b682d5c5ae" args="(void const *x, int size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int st_numhash </td>
          <td>(</td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Integral number hash function. </p>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="st_8h.html#a243e6ea7c74f6a18e2de12f2cf4114ef" title="Creates and initializes a table.">st_init_table</a> <a class="el" href="st_8h.html#a2191f7e83e64aa300a356a41da92bd6c" title="Integral number comparison function.">st_numcmp</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a498b5be01ce89910cfc8d3d95d68032c"></a><!-- doxytag: member="st.c::st_ptrcmp" ref="a498b5be01ce89910cfc8d3d95d68032c" args="(void const *x, void const *y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int st_ptrcmp </td>
          <td>(</td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pointer comparison function. </p>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="st_8h.html#a243e6ea7c74f6a18e2de12f2cf4114ef" title="Creates and initializes a table.">st_init_table</a> <a class="el" href="st_8h.html#a15f5c4bc5bbf978ae019fa7ce7c30175" title="Pointer hash function.">st_ptrhash</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a60ac0bfd65626294270cf1170c901563"></a><!-- doxytag: member="st.c::st_ptrhash" ref="a60ac0bfd65626294270cf1170c901563" args="(void const *x, int size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int st_ptrhash </td>
          <td>(</td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pointer hash function. </p>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="st_8h.html#a243e6ea7c74f6a18e2de12f2cf4114ef" title="Creates and initializes a table.">st_init_table</a> <a class="el" href="st_8h.html#a38d602b4313f73e14a16f886601fc670" title="Pointer comparison function.">st_ptrcmp</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae04fa098acd6e45c99d7a5fca22757c4"></a><!-- doxytag: member="st.c::st_strhash" ref="ae04fa098acd6e45c99d7a5fca22757c4" args="(void const *string, int modulus)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int st_strhash </td>
          <td>(</td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>modulus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>String hash function. </p>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="st_8h.html#a243e6ea7c74f6a18e2de12f2cf4114ef" title="Creates and initializes a table.">st_init_table</a> </dd></dl>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Thu May 12 2022 22:59:11 for cudd by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
