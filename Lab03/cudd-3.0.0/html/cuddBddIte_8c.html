<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>cudd: cudd/cuddBddIte.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">cudd&#160;<span id="projectnumber">3.0.0</span></div>
   <div id="projectbrief">The University of Colorado Decision Diagram Package</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>cudd/cuddBddIte.c File Reference<div class="ingroups"><a class="el" href="group__cudd.html">cudd</a></div></h1>  </div>
</div>
<div class="contents">

<p>BDD ITE function and satellites.  
<a href="#_details">More...</a></p>
<div class="textblock"><code>#include &quot;util.h&quot;</code><br/>
<code>#include &quot;<a class="el" href="cuddInt_8h_source.html">cuddInt.h</a>&quot;</code><br/>
</div><div class="textblock"><div class="dynheader">
Include dependency graph for cuddBddIte.c:</div>
<div class="dyncontent">
<div class="center"><img src="cuddBddIte_8c__incl.png" border="0" usemap="#cudd_2cuddBddIte_8c" alt=""/></div>
<map name="cudd_2cuddBddIte_8c" id="cudd_2cuddBddIte_8c">
<area shape="rect" id="node3" href="cuddInt_8h.html" title="Internal data structures of the CUDD package." alt="" coords="239,80,315,107"/><area shape="rect" id="node5" href="config_8h_source.html" title="config.h" alt="" coords="91,155,159,181"/><area shape="rect" id="node9" href="cudd_8h.html" title="The University of Colorado decision diagram package." alt="" coords="407,155,468,181"/></map>
</div>
</div><table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddBddIte_8c.html#a3f5761d50898785418ebcaccefb18a93">Cudd_bddIte</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *g, <a class="el" href="structDdNode.html">DdNode</a> *h)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements ITE(f,g,h).  <a href="#a3f5761d50898785418ebcaccefb18a93"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddBddIte_8c.html#a41cc655c685b3822fc21663dfaebdfc6">Cudd_bddIteLimit</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *g, <a class="el" href="structDdNode.html">DdNode</a> *h, unsigned int limit)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements ITE(f,g,h) unless too many nodes are required.  <a href="#a41cc655c685b3822fc21663dfaebdfc6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddBddIte_8c.html#ae893c6ab0472d7058bd424d02bc9420f">Cudd_bddIteConstant</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *g, <a class="el" href="structDdNode.html">DdNode</a> *h)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements ITEconstant(f,g,h).  <a href="#ae893c6ab0472d7058bd424d02bc9420f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddBddIte_8c.html#a6dc109a28a03aae73d3390dc5846a8cb">Cudd_bddIntersect</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *g)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a function included in the intersection of f and g.  <a href="#a6dc109a28a03aae73d3390dc5846a8cb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddBddIte_8c.html#a8374b23de03000aeafb9b6deecee4b3c">Cudd_bddAnd</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *g)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the conjunction of two BDDs f and g.  <a href="#a8374b23de03000aeafb9b6deecee4b3c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddBddIte_8c.html#adfbb2fd5b9c884df0d684a86dc26a97d">Cudd_bddAndLimit</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *g, unsigned int limit)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the conjunction of two BDDs f and g unless too many nodes are required.  <a href="#adfbb2fd5b9c884df0d684a86dc26a97d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddBddIte_8c.html#ad9dd195b3599f9101ff65b57e494f445">Cudd_bddOr</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *g)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the disjunction of two BDDs f and g.  <a href="#ad9dd195b3599f9101ff65b57e494f445"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddBddIte_8c.html#a6cbc77f8b658ac3c88a2549a84c58b38">Cudd_bddOrLimit</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *g, unsigned int limit)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the disjunction of two BDDs f and g unless too many nodes are required.  <a href="#a6cbc77f8b658ac3c88a2549a84c58b38"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddBddIte_8c.html#a98d4502750f55f79f7d21ce4674bd66f">Cudd_bddNand</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *g)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the NAND of two BDDs f and g.  <a href="#a98d4502750f55f79f7d21ce4674bd66f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddBddIte_8c.html#a3bb902e010f3213ba3a0e7917e93b70e">Cudd_bddNor</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *g)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the NOR of two BDDs f and g.  <a href="#a3bb902e010f3213ba3a0e7917e93b70e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddBddIte_8c.html#ad2215420b94afbcd00d011fe2787c5e7">Cudd_bddXor</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *g)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the exclusive OR of two BDDs f and g.  <a href="#ad2215420b94afbcd00d011fe2787c5e7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddBddIte_8c.html#a452caf40a12400757e44fe5a8569e20c">Cudd_bddXnor</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *g)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the exclusive NOR of two BDDs f and g.  <a href="#a452caf40a12400757e44fe5a8569e20c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddBddIte_8c.html#ae7422788984a855fb387643f27294014">Cudd_bddXnorLimit</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *g, unsigned int limit)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the exclusive NOR of two BDDs f and g unless too many nodes are required.  <a href="#ae7422788984a855fb387643f27294014"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddBddIte_8c.html#a89a46089e8572876a1521cdee6cb31a2">Cudd_bddLeq</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *g)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether f is less than or equal to g.  <a href="#a89a46089e8572876a1521cdee6cb31a2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddBddIte_8c.html#a6d52cd44b8033b3be8f23d21c46cd425">cuddBddIteRecur</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *g, <a class="el" href="structDdNode.html">DdNode</a> *h)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the recursive step of Cudd_bddIte.  <a href="#a6d52cd44b8033b3be8f23d21c46cd425"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddBddIte_8c.html#aa43deef9cc0de026d2b4917aef1b4d62">cuddBddIntersectRecur</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *g)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the recursive step of Cudd_bddIntersect.  <a href="#aa43deef9cc0de026d2b4917aef1b4d62"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddBddIte_8c.html#a1766cd8bf8b2ec57ade0db1a461e352b">cuddBddAndRecur</a> (<a class="el" href="structDdManager.html">DdManager</a> *manager, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *g)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the recursive step of Cudd_bddAnd.  <a href="#a1766cd8bf8b2ec57ade0db1a461e352b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddBddIte_8c.html#aed935896575aab5d56fefdd6d351b676">cuddBddXorRecur</a> (<a class="el" href="structDdManager.html">DdManager</a> *manager, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *g)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the recursive step of Cudd_bddXor.  <a href="#aed935896575aab5d56fefdd6d351b676"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddBddIte_8c.html#a7e4a04115909c79defdfc98ebfb72185">bddVarToConst</a> (<a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> **gp, <a class="el" href="structDdNode.html">DdNode</a> **hp, <a class="el" href="structDdNode.html">DdNode</a> *one)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces variables with constants if possible.  <a href="#a7e4a04115909c79defdfc98ebfb72185"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddBddIte_8c.html#a0a0db5d41fa010fac20f949b1db5a011">bddVarToCanonical</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> **fp, <a class="el" href="structDdNode.html">DdNode</a> **gp, <a class="el" href="structDdNode.html">DdNode</a> **hp, int *topfp, int *topgp, int *tophp)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Picks unique member from equiv expressions.  <a href="#a0a0db5d41fa010fac20f949b1db5a011"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddBddIte_8c.html#a11d291e758c1dcb4b1422f1079c440eb">bddVarToCanonicalSimple</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> **fp, <a class="el" href="structDdNode.html">DdNode</a> **gp, <a class="el" href="structDdNode.html">DdNode</a> **hp, int *topfp, int *topgp, int *tophp)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Picks unique member from equiv expressions.  <a href="#a11d291e758c1dcb4b1422f1079c440eb"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>BDD ITE function and satellites. </p>
<dl class="author"><dt><b>Author:</b></dt><dd>Fabio Somenzi</dd></dl>
<p>Copyright (c) 1995-2015, Regents of the University of Colorado</p>
<p>All rights reserved.</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p>
<p>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</p>
<p>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</p>
<p>Neither the name of the University of Colorado nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</p>
<p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  </p>
</div><hr/><h2>Function Documentation</h2>
<a class="anchor" id="a0a0db5d41fa010fac20f949b1db5a011"></a><!-- doxytag: member="cuddBddIte.c::bddVarToCanonical" ref="a0a0db5d41fa010fac20f949b1db5a011" args="(DdManager *dd, DdNode **fp, DdNode **gp, DdNode **hp, int *topfp, int *topgp, int *tophp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bddVarToCanonical </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>gp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>hp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>topfp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>topgp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>tophp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Picks unique member from equiv expressions. </p>
<p>Reduces 2 variable expressions to canonical form.</p>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddBddIte_8c.html#a7e4a04115909c79defdfc98ebfb72185" title="Replaces variables with constants if possible.">bddVarToConst</a> <a class="el" href="cuddBddIte_8c.html#a11d291e758c1dcb4b1422f1079c440eb" title="Picks unique member from equiv expressions.">bddVarToCanonicalSimple</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a11d291e758c1dcb4b1422f1079c440eb"></a><!-- doxytag: member="cuddBddIte.c::bddVarToCanonicalSimple" ref="a11d291e758c1dcb4b1422f1079c440eb" args="(DdManager *dd, DdNode **fp, DdNode **gp, DdNode **hp, int *topfp, int *topgp, int *tophp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bddVarToCanonicalSimple </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>gp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>hp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>topfp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>topgp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>tophp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Picks unique member from equiv expressions. </p>
<p>Makes sure the first two pointers are regular. This mat require the complementation of the result, which is signaled by returning 1 instead of 0. This function is simpler than the general case because it assumes that no two arguments are the same or complementary, and no argument is constant.</p>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddBddIte_8c.html#a7e4a04115909c79defdfc98ebfb72185" title="Replaces variables with constants if possible.">bddVarToConst</a> <a class="el" href="cuddBddIte_8c.html#a0a0db5d41fa010fac20f949b1db5a011" title="Picks unique member from equiv expressions.">bddVarToCanonical</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7e4a04115909c79defdfc98ebfb72185"></a><!-- doxytag: member="cuddBddIte.c::bddVarToConst" ref="a7e4a04115909c79defdfc98ebfb72185" args="(DdNode *f, DdNode **gp, DdNode **hp, DdNode *one)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bddVarToConst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>gp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>hp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>one</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Replaces variables with constants if possible. </p>
<p>This function performs part of the transformation to standard form by replacing variables with constants if possible.</p>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddBddIte_8c.html#a0a0db5d41fa010fac20f949b1db5a011" title="Picks unique member from equiv expressions.">bddVarToCanonical</a> <a class="el" href="cuddBddIte_8c.html#a11d291e758c1dcb4b1422f1079c440eb" title="Picks unique member from equiv expressions.">bddVarToCanonicalSimple</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8374b23de03000aeafb9b6deecee4b3c"></a><!-- doxytag: member="cuddBddIte.c::Cudd_bddAnd" ref="a8374b23de03000aeafb9b6deecee4b3c" args="(DdManager *dd, DdNode *f, DdNode *g)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddAnd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the conjunction of two BDDs f and g. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the resulting BDD if successful; NULL if the intermediate result blows up.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddBddIte_8c.html#a3f5761d50898785418ebcaccefb18a93" title="Implements ITE(f,g,h).">Cudd_bddIte</a> <a class="el" href="cuddAddApply_8c.html#ae8300acf801bcde789878fccb3635d5f" title="Applies op to the corresponding discriminants of f and g.">Cudd_addApply</a> <a class="el" href="cuddAndAbs_8c.html#af85814dd5f29584d937ad0129cee1afe" title="Takes the AND of two BDDs and simultaneously abstracts the variables in cube.">Cudd_bddAndAbstract</a> <a class="el" href="cuddBddIte_8c.html#a6dc109a28a03aae73d3390dc5846a8cb" title="Returns a function included in the intersection of f and g.">Cudd_bddIntersect</a> <a class="el" href="cuddBddIte_8c.html#ad9dd195b3599f9101ff65b57e494f445" title="Computes the disjunction of two BDDs f and g.">Cudd_bddOr</a> <a class="el" href="cuddBddIte_8c.html#a98d4502750f55f79f7d21ce4674bd66f" title="Computes the NAND of two BDDs f and g.">Cudd_bddNand</a> <a class="el" href="cuddBddIte_8c.html#a3bb902e010f3213ba3a0e7917e93b70e" title="Computes the NOR of two BDDs f and g.">Cudd_bddNor</a> <a class="el" href="cuddBddIte_8c.html#ad2215420b94afbcd00d011fe2787c5e7" title="Computes the exclusive OR of two BDDs f and g.">Cudd_bddXor</a> <a class="el" href="cuddBddIte_8c.html#a452caf40a12400757e44fe5a8569e20c" title="Computes the exclusive NOR of two BDDs f and g.">Cudd_bddXnor</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>first operand </td></tr>
    <tr><td class="paramname">g</td><td>second operand </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adfbb2fd5b9c884df0d684a86dc26a97d"></a><!-- doxytag: member="cuddBddIte.c::Cudd_bddAndLimit" ref="adfbb2fd5b9c884df0d684a86dc26a97d" args="(DdManager *dd, DdNode *f, DdNode *g, unsigned int limit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddAndLimit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the conjunction of two BDDs f and g unless too many nodes are required. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the resulting BDD if successful; NULL if the intermediate result blows up or more new nodes than `limit` are required.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddBddIte_8c.html#a8374b23de03000aeafb9b6deecee4b3c" title="Computes the conjunction of two BDDs f and g.">Cudd_bddAnd</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>first operand </td></tr>
    <tr><td class="paramname">g</td><td>second operand </td></tr>
    <tr><td class="paramname">limit</td><td>maximum number of new nodes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6dc109a28a03aae73d3390dc5846a8cb"></a><!-- doxytag: member="cuddBddIte.c::Cudd_bddIntersect" ref="a6dc109a28a03aae73d3390dc5846a8cb" args="(DdManager *dd, DdNode *f, DdNode *g)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddIntersect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a function included in the intersection of f and g. </p>
<p>The function computed (if not zero) is a witness that the intersection is not empty. Cudd_bddIntersect tries to build as few new nodes as possible. If the only result of interest is whether f and g intersect, Cudd_bddLeq should be used instead.</p>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddBddIte_8c.html#a89a46089e8572876a1521cdee6cb31a2" title="Checks whether f is less than or equal to g.">Cudd_bddLeq</a> <a class="el" href="cuddBddIte_8c.html#ae893c6ab0472d7058bd424d02bc9420f" title="Implements ITEconstant(f,g,h).">Cudd_bddIteConstant</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>first operand </td></tr>
    <tr><td class="paramname">g</td><td>second operand </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3f5761d50898785418ebcaccefb18a93"></a><!-- doxytag: member="cuddBddIte.c::Cudd_bddIte" ref="a3f5761d50898785418ebcaccefb18a93" args="(DdManager *dd, DdNode *f, DdNode *g, DdNode *h)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddIte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements ITE(f,g,h). </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the resulting BDD if successful; NULL if the intermediate result blows up.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddAddIte_8c.html#a385a1fdc578cf9e41ff15ef50b6870df" title="Implements ITE(f,g,h).">Cudd_addIte</a> <a class="el" href="cuddBddIte_8c.html#ae893c6ab0472d7058bd424d02bc9420f" title="Implements ITEconstant(f,g,h).">Cudd_bddIteConstant</a> <a class="el" href="cuddBddIte_8c.html#a6dc109a28a03aae73d3390dc5846a8cb" title="Returns a function included in the intersection of f and g.">Cudd_bddIntersect</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>first operand </td></tr>
    <tr><td class="paramname">g</td><td>second operand </td></tr>
    <tr><td class="paramname">h</td><td>third operand </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae893c6ab0472d7058bd424d02bc9420f"></a><!-- doxytag: member="cuddBddIte.c::Cudd_bddIteConstant" ref="ae893c6ab0472d7058bd424d02bc9420f" args="(DdManager *dd, DdNode *f, DdNode *g, DdNode *h)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddIteConstant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements ITEconstant(f,g,h). </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the resulting BDD (which may or may not be constant) or DD_NON_CONSTANT.</dd></dl>
<p>No new nodes are created.</p>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddBddIte_8c.html#a3f5761d50898785418ebcaccefb18a93" title="Implements ITE(f,g,h).">Cudd_bddIte</a> <a class="el" href="cuddBddIte_8c.html#a6dc109a28a03aae73d3390dc5846a8cb" title="Returns a function included in the intersection of f and g.">Cudd_bddIntersect</a> <a class="el" href="cuddBddIte_8c.html#a89a46089e8572876a1521cdee6cb31a2" title="Checks whether f is less than or equal to g.">Cudd_bddLeq</a> <a class="el" href="cuddAddIte_8c.html#ad1eae04162ef0a94b49121add887ee99" title="Implements ITEconstant for ADDs.">Cudd_addIteConstant</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>first operand </td></tr>
    <tr><td class="paramname">g</td><td>second operand </td></tr>
    <tr><td class="paramname">h</td><td>thord operand </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a41cc655c685b3822fc21663dfaebdfc6"></a><!-- doxytag: member="cuddBddIte.c::Cudd_bddIteLimit" ref="a41cc655c685b3822fc21663dfaebdfc6" args="(DdManager *dd, DdNode *f, DdNode *g, DdNode *h, unsigned int limit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddIteLimit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements ITE(f,g,h) unless too many nodes are required. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the resulting BDD if successful; NULL if the intermediate result blows up or more new nodes than `limit` are required.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddBddIte_8c.html#a3f5761d50898785418ebcaccefb18a93" title="Implements ITE(f,g,h).">Cudd_bddIte</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>first operand </td></tr>
    <tr><td class="paramname">g</td><td>second operand </td></tr>
    <tr><td class="paramname">h</td><td>third operand </td></tr>
    <tr><td class="paramname">limit</td><td>maximum number of new nodes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a89a46089e8572876a1521cdee6cb31a2"></a><!-- doxytag: member="cuddBddIte.c::Cudd_bddLeq" ref="a89a46089e8572876a1521cdee6cb31a2" args="(DdManager *dd, DdNode *f, DdNode *g)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_bddLeq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks whether f is less than or equal to g. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if f is less than or equal to g; 0 otherwise.</dd></dl>
<p>No new nodes are created.</p>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddBddIte_8c.html#ae893c6ab0472d7058bd424d02bc9420f" title="Implements ITEconstant(f,g,h).">Cudd_bddIteConstant</a> <a class="el" href="cuddAddIte_8c.html#a88cac595be91f0524a8be01c2b330661" title="Checks whether ADD g is constant whenever ADD f is 1.">Cudd_addEvalConst</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>first operand </td></tr>
    <tr><td class="paramname">g</td><td>second operand </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a98d4502750f55f79f7d21ce4674bd66f"></a><!-- doxytag: member="cuddBddIte.c::Cudd_bddNand" ref="a98d4502750f55f79f7d21ce4674bd66f" args="(DdManager *dd, DdNode *f, DdNode *g)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddNand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the NAND of two BDDs f and g. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the resulting BDD if successful; NULL if the intermediate result blows up.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddBddIte_8c.html#a3f5761d50898785418ebcaccefb18a93" title="Implements ITE(f,g,h).">Cudd_bddIte</a> <a class="el" href="cuddAddApply_8c.html#ae8300acf801bcde789878fccb3635d5f" title="Applies op to the corresponding discriminants of f and g.">Cudd_addApply</a> <a class="el" href="cuddBddIte_8c.html#a8374b23de03000aeafb9b6deecee4b3c" title="Computes the conjunction of two BDDs f and g.">Cudd_bddAnd</a> <a class="el" href="cuddBddIte_8c.html#ad9dd195b3599f9101ff65b57e494f445" title="Computes the disjunction of two BDDs f and g.">Cudd_bddOr</a> <a class="el" href="cuddBddIte_8c.html#a3bb902e010f3213ba3a0e7917e93b70e" title="Computes the NOR of two BDDs f and g.">Cudd_bddNor</a> <a class="el" href="cuddBddIte_8c.html#ad2215420b94afbcd00d011fe2787c5e7" title="Computes the exclusive OR of two BDDs f and g.">Cudd_bddXor</a> <a class="el" href="cuddBddIte_8c.html#a452caf40a12400757e44fe5a8569e20c" title="Computes the exclusive NOR of two BDDs f and g.">Cudd_bddXnor</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>first operand </td></tr>
    <tr><td class="paramname">g</td><td>second operand </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3bb902e010f3213ba3a0e7917e93b70e"></a><!-- doxytag: member="cuddBddIte.c::Cudd_bddNor" ref="a3bb902e010f3213ba3a0e7917e93b70e" args="(DdManager *dd, DdNode *f, DdNode *g)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddNor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the NOR of two BDDs f and g. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the resulting BDD if successful; NULL if the intermediate result blows up.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddBddIte_8c.html#a3f5761d50898785418ebcaccefb18a93" title="Implements ITE(f,g,h).">Cudd_bddIte</a> <a class="el" href="cuddAddApply_8c.html#ae8300acf801bcde789878fccb3635d5f" title="Applies op to the corresponding discriminants of f and g.">Cudd_addApply</a> <a class="el" href="cuddBddIte_8c.html#a8374b23de03000aeafb9b6deecee4b3c" title="Computes the conjunction of two BDDs f and g.">Cudd_bddAnd</a> <a class="el" href="cuddBddIte_8c.html#ad9dd195b3599f9101ff65b57e494f445" title="Computes the disjunction of two BDDs f and g.">Cudd_bddOr</a> <a class="el" href="cuddBddIte_8c.html#a98d4502750f55f79f7d21ce4674bd66f" title="Computes the NAND of two BDDs f and g.">Cudd_bddNand</a> <a class="el" href="cuddBddIte_8c.html#ad2215420b94afbcd00d011fe2787c5e7" title="Computes the exclusive OR of two BDDs f and g.">Cudd_bddXor</a> <a class="el" href="cuddBddIte_8c.html#a452caf40a12400757e44fe5a8569e20c" title="Computes the exclusive NOR of two BDDs f and g.">Cudd_bddXnor</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>first operand </td></tr>
    <tr><td class="paramname">g</td><td>second operand </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad9dd195b3599f9101ff65b57e494f445"></a><!-- doxytag: member="cuddBddIte.c::Cudd_bddOr" ref="ad9dd195b3599f9101ff65b57e494f445" args="(DdManager *dd, DdNode *f, DdNode *g)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddOr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the disjunction of two BDDs f and g. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the resulting BDD if successful; NULL if the intermediate result blows up.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddBddIte_8c.html#a3f5761d50898785418ebcaccefb18a93" title="Implements ITE(f,g,h).">Cudd_bddIte</a> <a class="el" href="cuddAddApply_8c.html#ae8300acf801bcde789878fccb3635d5f" title="Applies op to the corresponding discriminants of f and g.">Cudd_addApply</a> <a class="el" href="cuddBddIte_8c.html#a8374b23de03000aeafb9b6deecee4b3c" title="Computes the conjunction of two BDDs f and g.">Cudd_bddAnd</a> <a class="el" href="cuddBddIte_8c.html#a98d4502750f55f79f7d21ce4674bd66f" title="Computes the NAND of two BDDs f and g.">Cudd_bddNand</a> <a class="el" href="cuddBddIte_8c.html#a3bb902e010f3213ba3a0e7917e93b70e" title="Computes the NOR of two BDDs f and g.">Cudd_bddNor</a> <a class="el" href="cuddBddIte_8c.html#ad2215420b94afbcd00d011fe2787c5e7" title="Computes the exclusive OR of two BDDs f and g.">Cudd_bddXor</a> <a class="el" href="cuddBddIte_8c.html#a452caf40a12400757e44fe5a8569e20c" title="Computes the exclusive NOR of two BDDs f and g.">Cudd_bddXnor</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>first operand </td></tr>
    <tr><td class="paramname">g</td><td>second operand </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6cbc77f8b658ac3c88a2549a84c58b38"></a><!-- doxytag: member="cuddBddIte.c::Cudd_bddOrLimit" ref="a6cbc77f8b658ac3c88a2549a84c58b38" args="(DdManager *dd, DdNode *f, DdNode *g, unsigned int limit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddOrLimit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the disjunction of two BDDs f and g unless too many nodes are required. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the resulting BDD if successful; NULL if the intermediate result blows up or more new nodes than `limit` are required.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddBddIte_8c.html#ad9dd195b3599f9101ff65b57e494f445" title="Computes the disjunction of two BDDs f and g.">Cudd_bddOr</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>first operand </td></tr>
    <tr><td class="paramname">g</td><td>second operand </td></tr>
    <tr><td class="paramname">limit</td><td>maximum number of new nodes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a452caf40a12400757e44fe5a8569e20c"></a><!-- doxytag: member="cuddBddIte.c::Cudd_bddXnor" ref="a452caf40a12400757e44fe5a8569e20c" args="(DdManager *dd, DdNode *f, DdNode *g)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddXnor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the exclusive NOR of two BDDs f and g. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the resulting BDD if successful; NULL if the intermediate result blows up.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddBddIte_8c.html#a3f5761d50898785418ebcaccefb18a93" title="Implements ITE(f,g,h).">Cudd_bddIte</a> <a class="el" href="cuddAddApply_8c.html#ae8300acf801bcde789878fccb3635d5f" title="Applies op to the corresponding discriminants of f and g.">Cudd_addApply</a> <a class="el" href="cuddBddIte_8c.html#a8374b23de03000aeafb9b6deecee4b3c" title="Computes the conjunction of two BDDs f and g.">Cudd_bddAnd</a> <a class="el" href="cuddBddIte_8c.html#ad9dd195b3599f9101ff65b57e494f445" title="Computes the disjunction of two BDDs f and g.">Cudd_bddOr</a> <a class="el" href="cuddBddIte_8c.html#a98d4502750f55f79f7d21ce4674bd66f" title="Computes the NAND of two BDDs f and g.">Cudd_bddNand</a> <a class="el" href="cuddBddIte_8c.html#a3bb902e010f3213ba3a0e7917e93b70e" title="Computes the NOR of two BDDs f and g.">Cudd_bddNor</a> <a class="el" href="cuddBddIte_8c.html#ad2215420b94afbcd00d011fe2787c5e7" title="Computes the exclusive OR of two BDDs f and g.">Cudd_bddXor</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>first operand </td></tr>
    <tr><td class="paramname">g</td><td>second operand </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae7422788984a855fb387643f27294014"></a><!-- doxytag: member="cuddBddIte.c::Cudd_bddXnorLimit" ref="ae7422788984a855fb387643f27294014" args="(DdManager *dd, DdNode *f, DdNode *g, unsigned int limit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddXnorLimit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the exclusive NOR of two BDDs f and g unless too many nodes are required. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the resulting BDD if successful; NULL if the intermediate result blows up or more new nodes than `limit` are required.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddBddIte_8c.html#a452caf40a12400757e44fe5a8569e20c" title="Computes the exclusive NOR of two BDDs f and g.">Cudd_bddXnor</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>first operand </td></tr>
    <tr><td class="paramname">g</td><td>second operand </td></tr>
    <tr><td class="paramname">limit</td><td>maximum number of new nodes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad2215420b94afbcd00d011fe2787c5e7"></a><!-- doxytag: member="cuddBddIte.c::Cudd_bddXor" ref="ad2215420b94afbcd00d011fe2787c5e7" args="(DdManager *dd, DdNode *f, DdNode *g)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddXor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the exclusive OR of two BDDs f and g. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the resulting BDD if successful; NULL if the intermediate result blows up.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddBddIte_8c.html#a3f5761d50898785418ebcaccefb18a93" title="Implements ITE(f,g,h).">Cudd_bddIte</a> <a class="el" href="cuddAddApply_8c.html#ae8300acf801bcde789878fccb3635d5f" title="Applies op to the corresponding discriminants of f and g.">Cudd_addApply</a> <a class="el" href="cuddBddIte_8c.html#a8374b23de03000aeafb9b6deecee4b3c" title="Computes the conjunction of two BDDs f and g.">Cudd_bddAnd</a> <a class="el" href="cuddBddIte_8c.html#ad9dd195b3599f9101ff65b57e494f445" title="Computes the disjunction of two BDDs f and g.">Cudd_bddOr</a> <a class="el" href="cuddBddIte_8c.html#a98d4502750f55f79f7d21ce4674bd66f" title="Computes the NAND of two BDDs f and g.">Cudd_bddNand</a> <a class="el" href="cuddBddIte_8c.html#a3bb902e010f3213ba3a0e7917e93b70e" title="Computes the NOR of two BDDs f and g.">Cudd_bddNor</a> <a class="el" href="cuddBddIte_8c.html#a452caf40a12400757e44fe5a8569e20c" title="Computes the exclusive NOR of two BDDs f and g.">Cudd_bddXnor</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>first operand </td></tr>
    <tr><td class="paramname">g</td><td>second operand </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1766cd8bf8b2ec57ade0db1a461e352b"></a><!-- doxytag: member="cuddBddIte.c::cuddBddAndRecur" ref="a1766cd8bf8b2ec57ade0db1a461e352b" args="(DdManager *manager, DdNode *f, DdNode *g)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* cuddBddAndRecur </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements the recursive step of Cudd_bddAnd. </p>
<p>Takes the conjunction of two BDDs.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the result is successful; NULL otherwise.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddBddIte_8c.html#a8374b23de03000aeafb9b6deecee4b3c" title="Computes the conjunction of two BDDs f and g.">Cudd_bddAnd</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa43deef9cc0de026d2b4917aef1b4d62"></a><!-- doxytag: member="cuddBddIte.c::cuddBddIntersectRecur" ref="aa43deef9cc0de026d2b4917aef1b4d62" args="(DdManager *dd, DdNode *f, DdNode *g)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* cuddBddIntersectRecur </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements the recursive step of Cudd_bddIntersect. </p>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddBddIte_8c.html#a6dc109a28a03aae73d3390dc5846a8cb" title="Returns a function included in the intersection of f and g.">Cudd_bddIntersect</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6d52cd44b8033b3be8f23d21c46cd425"></a><!-- doxytag: member="cuddBddIte.c::cuddBddIteRecur" ref="a6d52cd44b8033b3be8f23d21c46cd425" args="(DdManager *dd, DdNode *f, DdNode *g, DdNode *h)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* cuddBddIteRecur </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements the recursive step of Cudd_bddIte. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the resulting BDD. NULL if the intermediate result blows up or if reordering occurs.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="aed935896575aab5d56fefdd6d351b676"></a><!-- doxytag: member="cuddBddIte.c::cuddBddXorRecur" ref="aed935896575aab5d56fefdd6d351b676" args="(DdManager *manager, DdNode *f, DdNode *g)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* cuddBddXorRecur </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements the recursive step of Cudd_bddXor. </p>
<p>Takes the exclusive OR of two BDDs.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the result is successful; NULL otherwise.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddBddIte_8c.html#ad2215420b94afbcd00d011fe2787c5e7" title="Computes the exclusive OR of two BDDs f and g.">Cudd_bddXor</a> </dd></dl>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Thu May 12 2022 22:59:10 for cudd by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
