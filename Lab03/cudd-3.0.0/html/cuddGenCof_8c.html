<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>cudd: cudd/cuddGenCof.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">cudd&#160;<span id="projectnumber">3.0.0</span></div>
   <div id="projectbrief">The University of Colorado Decision Diagram Package</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Defines</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>cudd/cuddGenCof.c File Reference<div class="ingroups"><a class="el" href="group__cudd.html">cudd</a></div></h1>  </div>
</div>
<div class="contents">

<p>Generalized cofactors for BDDs and ADDs.  
<a href="#_details">More...</a></p>
<div class="textblock"><code>#include &quot;util.h&quot;</code><br/>
<code>#include &quot;<a class="el" href="cuddInt_8h_source.html">cuddInt.h</a>&quot;</code><br/>
</div><div class="textblock"><div class="dynheader">
Include dependency graph for cuddGenCof.c:</div>
<div class="dyncontent">
<div class="center"><img src="cuddGenCof_8c__incl.png" border="0" usemap="#cudd_2cuddGenCof_8c" alt=""/></div>
<map name="cudd_2cuddGenCof_8c" id="cudd_2cuddGenCof_8c">
<area shape="rect" id="node3" href="cuddInt_8h.html" title="Internal data structures of the CUDD package." alt="" coords="239,80,315,107"/><area shape="rect" id="node5" href="config_8h_source.html" title="config.h" alt="" coords="91,155,159,181"/><area shape="rect" id="node9" href="cudd_8h.html" title="The University of Colorado decision diagram package." alt="" coords="407,155,468,181"/></map>
</div>
</div><table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMarkCacheKey.html">MarkCacheKey</a></td></tr>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a58e6e08b6d6eecaa27751fe9daa7572f"></a><!-- doxytag: member="cuddGenCof.c::DD_LIC_DC" ref="a58e6e08b6d6eecaa27751fe9daa7572f" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>DD_LIC_DC</b>&#160;&#160;&#160;0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a38013a854f3a3668b3884fa41ce4bb97"></a><!-- doxytag: member="cuddGenCof.c::DD_LIC_1" ref="a38013a854f3a3668b3884fa41ce4bb97" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>DD_LIC_1</b>&#160;&#160;&#160;1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a47f751f28a0a4c6bcbf8a7a0b00d7c5c"></a><!-- doxytag: member="cuddGenCof.c::DD_LIC_0" ref="a47f751f28a0a4c6bcbf8a7a0b00d7c5c" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>DD_LIC_0</b>&#160;&#160;&#160;2</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9dff231f69b4be9b27fc2eddde0c4fa6"></a><!-- doxytag: member="cuddGenCof.c::DD_LIC_NL" ref="a9dff231f69b4be9b27fc2eddde0c4fa6" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>DD_LIC_NL</b>&#160;&#160;&#160;3</td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structMarkCacheKey.html">MarkCacheKey</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddGenCof_8c.html#ae4c53e8f012b5e3530e97a52596846c4">MarkCacheKey</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddGenCof_8c.html#a250f801a2e5814da9d67a3436f0e3376">Cudd_bddConstrain</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *c)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes f constrain c.  <a href="#a250f801a2e5814da9d67a3436f0e3376"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddGenCof_8c.html#a3c8d8bb0210e368eb7258b2961c3cf3e">Cudd_bddRestrict</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *c)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">BDD restrict according to Coudert and Madre's algorithm (ICCAD90).  <a href="#a3c8d8bb0210e368eb7258b2961c3cf3e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddGenCof_8c.html#ab2c68fd99c5b8c0c854c0ba2f1944d39">Cudd_bddNPAnd</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *g)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes f non-polluting-and g.  <a href="#ab2c68fd99c5b8c0c854c0ba2f1944d39"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddGenCof_8c.html#a3bdc53bb832fb6b57528e7d5ceef7944">Cudd_addConstrain</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *c)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes f constrain c for ADDs.  <a href="#a3bdc53bb832fb6b57528e7d5ceef7944"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddGenCof_8c.html#aaaf0b345123f5065ac6b2ea951b7bfe8">Cudd_bddConstrainDecomp</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">BDD conjunctive decomposition as in McMillan's CAV96 paper.  <a href="#aaaf0b345123f5065ac6b2ea951b7bfe8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddGenCof_8c.html#a4ab16f58da620eb1c2e927426aea22c7">Cudd_addRestrict</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *c)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">ADD restrict according to Coudert and Madre's algorithm (ICCAD90).  <a href="#a4ab16f58da620eb1c2e927426aea22c7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddGenCof_8c.html#a1a4482b94e76db44ff22087277d09b4d">Cudd_bddCharToVect</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a vector of BDDs whose image equals a non-zero function.  <a href="#a1a4482b94e76db44ff22087277d09b4d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddGenCof_8c.html#a6c23e53c189d45d06b68a9a52b724141">Cudd_bddLICompaction</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *c)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs safe minimization of a BDD.  <a href="#a6c23e53c189d45d06b68a9a52b724141"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddGenCof_8c.html#afbc2329b3d7a6cb0b8adc5582fc7fe2c">Cudd_bddSqueeze</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *l, <a class="el" href="structDdNode.html">DdNode</a> *u)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a small BDD in a function interval.  <a href="#afbc2329b3d7a6cb0b8adc5582fc7fe2c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddGenCof_8c.html#aee71bb03723625bacf2c0b369a187125">Cudd_bddInterpolate</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *l, <a class="el" href="structDdNode.html">DdNode</a> *u)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an interpolant of two functions.  <a href="#aee71bb03723625bacf2c0b369a187125"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddGenCof_8c.html#af47227c86f08d37cd5fd8ea2a89afcb7">Cudd_bddMinimize</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *c)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a small BDD that agrees with `f` over `c`.  <a href="#af47227c86f08d37cd5fd8ea2a89afcb7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddGenCof_8c.html#abbc5a582b85170a4c365e852b98c37da">Cudd_SubsetCompress</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, int nvars, int threshold)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a dense subset of BDD `f`.  <a href="#abbc5a582b85170a4c365e852b98c37da"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddGenCof_8c.html#a194308bd7e4afce7aa668833f8a4e2ff">Cudd_SupersetCompress</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, int nvars, int threshold)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a dense superset of BDD `f`.  <a href="#a194308bd7e4afce7aa668833f8a4e2ff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddGenCof_8c.html#a6311f1cc598ee0f3681a76baec8c6d53">cuddBddConstrainRecur</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *c)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the recursive step of Cudd_bddConstrain.  <a href="#a6311f1cc598ee0f3681a76baec8c6d53"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddGenCof_8c.html#ac7fd377dc8f0df6472ca0fe6df41ae48">cuddBddRestrictRecur</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *c)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the recursive step of Cudd_bddRestrict.  <a href="#ac7fd377dc8f0df6472ca0fe6df41ae48"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddGenCof_8c.html#acf9e01bcb80c9d9fb11db7409de68638">cuddBddNPAndRecur</a> (<a class="el" href="structDdManager.html">DdManager</a> *manager, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *g)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the recursive step of Cudd_bddAnd.  <a href="#acf9e01bcb80c9d9fb11db7409de68638"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddGenCof_8c.html#abb45bdb200e1e4e975b20925130a6c66">cuddAddConstrainRecur</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *c)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the recursive step of Cudd_addConstrain.  <a href="#abb45bdb200e1e4e975b20925130a6c66"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddGenCof_8c.html#a560239ea1d3da12ff14b214f0adf17a4">cuddAddRestrictRecur</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *c)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the recursive step of Cudd_addRestrict.  <a href="#a560239ea1d3da12ff14b214f0adf17a4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddGenCof_8c.html#a6ac4647d91d277c68197d1860239dfbc">cuddBddLICompaction</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *c)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs safe minimization of a BDD.  <a href="#a6ac4647d91d277c68197d1860239dfbc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddGenCof_8c.html#a5eaea32f6ed375be93c707ce4f5fea3d">cuddBddConstrainDecomp</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> **decomp)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the recursive step of Cudd_bddConstrainDecomp.  <a href="#a5eaea32f6ed375be93c707ce4f5fea3d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddGenCof_8c.html#a544d6fe00d57c345745125eb2f426269">cuddBddCharToVect</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the recursive step of Cudd_bddCharToVect.  <a href="#a544d6fe00d57c345745125eb2f426269"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddGenCof_8c.html#a6816dc82d29be25bac7eec5068866537">cuddBddLICMarkEdges</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *c, <a class="el" href="structst__table.html">st_table</a> *table, <a class="el" href="structst__table.html">st_table</a> *cache)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the edge marking step of Cudd_bddLICompaction.  <a href="#a6816dc82d29be25bac7eec5068866537"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddGenCof_8c.html#a030d33ea12ccc3211150fb6a56899bd3">cuddBddLICBuildResult</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structst__table.html">st_table</a> *cache, <a class="el" href="structst__table.html">st_table</a> *table)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds the result of Cudd_bddLICompaction.  <a href="#a030d33ea12ccc3211150fb6a56899bd3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddGenCof_8c.html#ac56ab0c42e8725d6bb14715af44a2e65">MarkCacheHash</a> (void const *ptr, int modulus)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash function for the computed table of cuddBddLICMarkEdges.  <a href="#ac56ab0c42e8725d6bb14715af44a2e65"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddGenCof_8c.html#a29d7cf50fd4deeffde8d28af9fd15ecb">MarkCacheCompare</a> (const void *ptr1, const void *ptr2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison function for the computed table of cuddBddLICMarkEdges.  <a href="#a29d7cf50fd4deeffde8d28af9fd15ecb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static enum <a class="el" href="st_8h.html#a0c6a172fd99de7928916e65034ed8b1f">st_retval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddGenCof_8c.html#a90b8f5db40b9678f92372dbbac47f75b">MarkCacheCleanUp</a> (void *key, void *value, void *arg)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees memory associated with computed table of cuddBddLICMarkEdges.  <a href="#a90b8f5db40b9678f92372dbbac47f75b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddGenCof_8c.html#a95af9893c405bea9e49dba8632e8abb3">cuddBddSqueeze</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *l, <a class="el" href="structDdNode.html">DdNode</a> *u)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the recursive step of Cudd_bddSqueeze.  <a href="#a95af9893c405bea9e49dba8632e8abb3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddGenCof_8c.html#aea13cdf4c9cef5ded81a6fd74c21ce2d">cuddBddInterpolate</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *l, <a class="el" href="structDdNode.html">DdNode</a> *u)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the recursive step of Cudd_bddInterpolate.  <a href="#aea13cdf4c9cef5ded81a6fd74c21ce2d"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Generalized cofactors for BDDs and ADDs. </p>
<dl class="author"><dt><b>Author:</b></dt><dd>Fabio Somenzi</dd></dl>
<p>Copyright (c) 1995-2015, Regents of the University of Colorado</p>
<p>All rights reserved.</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p>
<p>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</p>
<p>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</p>
<p>Neither the name of the University of Colorado nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</p>
<p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  </p>
</div><hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ae4c53e8f012b5e3530e97a52596846c4"></a><!-- doxytag: member="cuddGenCof.c::MarkCacheKey" ref="ae4c53e8f012b5e3530e97a52596846c4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structMarkCacheKey.html">MarkCacheKey</a>  <a class="el" href="structMarkCacheKey.html">MarkCacheKey</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Key for the cache used in the edge marking phase. </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a3bdc53bb832fb6b57528e7d5ceef7944"></a><!-- doxytag: member="cuddGenCof.c::Cudd_addConstrain" ref="a3bdc53bb832fb6b57528e7d5ceef7944" args="(DdManager *dd, DdNode *f, DdNode *c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_addConstrain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes f constrain c for ADDs. </p>
<p>Computes f constrain c (f @ c), for f an ADD and c a 0-1 ADD. List of special cases: </p>
<ul>
<li>
F @ 0 = 0 </li>
<li>
F @ 1 = F </li>
<li>
0 @ c = 0 </li>
<li>
1 @ c = 1 </li>
<li>
F @ F = 1 </li>
</ul>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the result if successful; NULL otherwise.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddGenCof_8c.html#a250f801a2e5814da9d67a3436f0e3376" title="Computes f constrain c.">Cudd_bddConstrain</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4ab16f58da620eb1c2e927426aea22c7"></a><!-- doxytag: member="cuddGenCof.c::Cudd_addRestrict" ref="a4ab16f58da620eb1c2e927426aea22c7" args="(DdManager *dd, DdNode *f, DdNode *c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_addRestrict </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>ADD restrict according to Coudert and Madre's algorithm (ICCAD90). </p>
<p>If application of restrict results in an ADD larger than the input ADD, the input ADD is returned.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the restricted ADD if successful; otherwise NULL.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddGenCof_8c.html#a3bdc53bb832fb6b57528e7d5ceef7944" title="Computes f constrain c for ADDs.">Cudd_addConstrain</a> <a class="el" href="cuddGenCof_8c.html#a3c8d8bb0210e368eb7258b2961c3cf3e" title="BDD restrict according to Coudert and Madre&#39;s algorithm (ICCAD90).">Cudd_bddRestrict</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a1a4482b94e76db44ff22087277d09b4d"></a><!-- doxytag: member="cuddGenCof.c::Cudd_bddCharToVect" ref="a1a4482b94e76db44ff22087277d09b4d" args="(DdManager *dd, DdNode *f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>** Cudd_bddCharToVect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes a vector of BDDs whose image equals a non-zero function. </p>
<p>The result depends on the variable order. The i-th component of the vector depends only on the first i variables in the order. Each BDD in the vector is not larger than the BDD of the given characteristic function. This function is based on the description of char-to-vect in "Verification of
  Sequential Machines Using Boolean Functional Vectors" by O. Coudert, C. Berthet and J. C. Madre.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to an array containing the result if successful; NULL otherwise. The size of the array equals the number of variables in the manager. The components of the solution have their reference counts already incremented (unlike the results of most other functions in the package).</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddGenCof_8c.html#a250f801a2e5814da9d67a3436f0e3376" title="Computes f constrain c.">Cudd_bddConstrain</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a250f801a2e5814da9d67a3436f0e3376"></a><!-- doxytag: member="cuddGenCof.c::Cudd_bddConstrain" ref="a250f801a2e5814da9d67a3436f0e3376" args="(DdManager *dd, DdNode *f, DdNode *c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddConstrain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes f constrain c. </p>
<p>Computes f constrain c (f @ c). Uses a canonical form: (f' @ c) = (f @ c)'. (Note: this is not true for c.) List of special cases: </p>
<ul>
<li>
f @ 0 = 0 </li>
<li>
f @ 1 = f </li>
<li>
0 @ c = 0 </li>
<li>
1 @ c = 1 </li>
<li>
f @ f = 1 </li>
<li>
f @ f'= 0 </li>
</ul>
<p>Note that if F=(f1,...,fn) and reordering takes place while computing F @ c, then the image restriction property (Img(F,c) = Img(F @ c)) is lost.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the result if successful; NULL otherwise.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddGenCof_8c.html#a3c8d8bb0210e368eb7258b2961c3cf3e" title="BDD restrict according to Coudert and Madre&#39;s algorithm (ICCAD90).">Cudd_bddRestrict</a> <a class="el" href="cuddGenCof_8c.html#a3bdc53bb832fb6b57528e7d5ceef7944" title="Computes f constrain c for ADDs.">Cudd_addConstrain</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aaaf0b345123f5065ac6b2ea951b7bfe8"></a><!-- doxytag: member="cuddGenCof.c::Cudd_bddConstrainDecomp" ref="aaaf0b345123f5065ac6b2ea951b7bfe8" args="(DdManager *dd, DdNode *f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>** Cudd_bddConstrainDecomp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>BDD conjunctive decomposition as in McMillan's CAV96 paper. </p>
<p>The decomposition is canonical only for a given variable order. If canonicity is required, variable ordering must be disabled after the decomposition has been computed. The components of the solution have their reference counts already incremented (unlike the results of most other functions in the package).</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>an array with one entry for each BDD variable in the manager if successful; otherwise NULL.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddGenCof_8c.html#a250f801a2e5814da9d67a3436f0e3376" title="Computes f constrain c.">Cudd_bddConstrain</a> <a class="el" href="cuddBddAbs_8c.html#a38ddb1590403cc2c2d6c382b68835269" title="Existentially abstracts all the variables in cube from f.">Cudd_bddExistAbstract</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aee71bb03723625bacf2c0b369a187125"></a><!-- doxytag: member="cuddGenCof.c::Cudd_bddInterpolate" ref="aee71bb03723625bacf2c0b369a187125" args="(DdManager *dd, DdNode *l, DdNode *u)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddInterpolate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finds an interpolant of two functions. </p>
<p>Given BDDs `l` and `u`, representing the lower bound and upper bound of a function interval, Cudd_bddInterpolate produces the BDD of a function within the interval that only depends on the variables common to `l` and `u`.</p>
<p>The approach is based on quantification as in <a class="el" href="cudd_8h.html#a3c8d8bb0210e368eb7258b2961c3cf3e" title="BDD restrict according to Coudert and Madre&#39;s algorithm (ICCAD90).">Cudd_bddRestrict()</a>. The function assumes that `l` implies `u`, but does not check whether that's true.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the result if successful; NULL otherwise.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddGenCof_8c.html#a3c8d8bb0210e368eb7258b2961c3cf3e" title="BDD restrict according to Coudert and Madre&#39;s algorithm (ICCAD90).">Cudd_bddRestrict</a> <a class="el" href="cuddGenCof_8c.html#afbc2329b3d7a6cb0b8adc5582fc7fe2c" title="Finds a small BDD in a function interval.">Cudd_bddSqueeze</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">l</td><td>lower bound </td></tr>
    <tr><td class="paramname">u</td><td>upper bound </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6c23e53c189d45d06b68a9a52b724141"></a><!-- doxytag: member="cuddGenCof.c::Cudd_bddLICompaction" ref="a6c23e53c189d45d06b68a9a52b724141" args="(DdManager *dd, DdNode *f, DdNode *c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddLICompaction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs safe minimization of a BDD. </p>
<p>Given the BDD `f` of a function to be minimized and a BDD `c` representing the care set, Cudd_bddLICompaction produces the BDD of a function that agrees with `f` wherever `c` is 1. Safe minimization means that the size of the result is guaranteed not to exceed the size of `f`. This function is based on the DAC97 paper by Hong et al..</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the result if successful; NULL otherwise.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddGenCof_8c.html#a3c8d8bb0210e368eb7258b2961c3cf3e" title="BDD restrict according to Coudert and Madre&#39;s algorithm (ICCAD90).">Cudd_bddRestrict</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>function to be minimized </td></tr>
    <tr><td class="paramname">c</td><td>constraint (care set) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af47227c86f08d37cd5fd8ea2a89afcb7"></a><!-- doxytag: member="cuddGenCof.c::Cudd_bddMinimize" ref="af47227c86f08d37cd5fd8ea2a89afcb7" args="(DdManager *dd, DdNode *f, DdNode *c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddMinimize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finds a small BDD that agrees with `f` over `c`. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the result if successful; NULL otherwise.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddGenCof_8c.html#a3c8d8bb0210e368eb7258b2961c3cf3e" title="BDD restrict according to Coudert and Madre&#39;s algorithm (ICCAD90).">Cudd_bddRestrict</a> <a class="el" href="cuddGenCof_8c.html#a6c23e53c189d45d06b68a9a52b724141" title="Performs safe minimization of a BDD.">Cudd_bddLICompaction</a> <a class="el" href="cuddGenCof_8c.html#afbc2329b3d7a6cb0b8adc5582fc7fe2c" title="Finds a small BDD in a function interval.">Cudd_bddSqueeze</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab2c68fd99c5b8c0c854c0ba2f1944d39"></a><!-- doxytag: member="cuddGenCof.c::Cudd_bddNPAnd" ref="ab2c68fd99c5b8c0c854c0ba2f1944d39" args="(DdManager *dd, DdNode *f, DdNode *g)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddNPAnd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes f non-polluting-and g. </p>
<p>The non-polluting AND of f and g is a hybrid of AND and Restrict. From Restrict, this operation takes the idea of existentially quantifying the top variable of the second operand if it does not appear in the first. Therefore, the variables that appear in the result also appear in f. For the rest, the function behaves like AND. Since the two operands play different roles, non-polluting AND is not commutative.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the result if successful; NULL otherwise.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddGenCof_8c.html#a250f801a2e5814da9d67a3436f0e3376" title="Computes f constrain c.">Cudd_bddConstrain</a> <a class="el" href="cuddGenCof_8c.html#a3c8d8bb0210e368eb7258b2961c3cf3e" title="BDD restrict according to Coudert and Madre&#39;s algorithm (ICCAD90).">Cudd_bddRestrict</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3c8d8bb0210e368eb7258b2961c3cf3e"></a><!-- doxytag: member="cuddGenCof.c::Cudd_bddRestrict" ref="a3c8d8bb0210e368eb7258b2961c3cf3e" args="(DdManager *dd, DdNode *f, DdNode *c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddRestrict </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>BDD restrict according to Coudert and Madre's algorithm (ICCAD90). </p>
<p>If application of restrict results in a BDD larger than the input BDD, the input BDD is returned.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the restricted BDD if successful; otherwise NULL.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddGenCof_8c.html#a250f801a2e5814da9d67a3436f0e3376" title="Computes f constrain c.">Cudd_bddConstrain</a> <a class="el" href="cuddGenCof_8c.html#a4ab16f58da620eb1c2e927426aea22c7" title="ADD restrict according to Coudert and Madre&#39;s algorithm (ICCAD90).">Cudd_addRestrict</a> </dd></dl>

</div>
</div>
<a class="anchor" id="afbc2329b3d7a6cb0b8adc5582fc7fe2c"></a><!-- doxytag: member="cuddGenCof.c::Cudd_bddSqueeze" ref="afbc2329b3d7a6cb0b8adc5582fc7fe2c" args="(DdManager *dd, DdNode *l, DdNode *u)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddSqueeze </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finds a small BDD in a function interval. </p>
<p>Given BDDs `l` and `u`, representing the lower bound and upper bound of a function interval, Cudd_bddSqueeze produces the BDD of a function within the interval with a small BDD.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the result if successful; NULL otherwise.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddGenCof_8c.html#a3c8d8bb0210e368eb7258b2961c3cf3e" title="BDD restrict according to Coudert and Madre&#39;s algorithm (ICCAD90).">Cudd_bddRestrict</a> <a class="el" href="cuddGenCof_8c.html#a6c23e53c189d45d06b68a9a52b724141" title="Performs safe minimization of a BDD.">Cudd_bddLICompaction</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">l</td><td>lower bound </td></tr>
    <tr><td class="paramname">u</td><td>upper bound </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abbc5a582b85170a4c365e852b98c37da"></a><!-- doxytag: member="cuddGenCof.c::Cudd_SubsetCompress" ref="abbc5a582b85170a4c365e852b98c37da" args="(DdManager *dd, DdNode *f, int nvars, int threshold)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_SubsetCompress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nvars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find a dense subset of BDD `f`. </p>
<p>Density is the ratio of number of minterms to number of nodes. Uses several techniques in series. It is more expensive than other subsetting procedures, but often produces better results. See Cudd_SubsetShortPaths for a description of the threshold and nvars parameters.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the result if successful; NULL otherwise.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddApprox_8c.html#a05f3e8b16e5df2eb681a68e6ee6906f3" title="Extracts a dense subset from a BDD with the remapping underapproximation method.">Cudd_RemapUnderApprox</a> <a class="el" href="cuddSubsetSP_8c.html#a890a2da46a4d6cec913e2ae57a9ab626" title="Extracts a dense subset from a BDD with the shortest paths heuristic.">Cudd_SubsetShortPaths</a> <a class="el" href="cuddSubsetHB_8c.html#a7579ecbb0187c4061cc2d45a3a21e68e" title="Extracts a dense subset from a BDD with the heavy branch heuristic.">Cudd_SubsetHeavyBranch</a> <a class="el" href="cuddGenCof_8c.html#afbc2329b3d7a6cb0b8adc5582fc7fe2c" title="Finds a small BDD in a function interval.">Cudd_bddSqueeze</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>BDD whose subset is sought </td></tr>
    <tr><td class="paramname">nvars</td><td>number of variables in the support of f </td></tr>
    <tr><td class="paramname">threshold</td><td>maximum number of nodes in the subset </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a194308bd7e4afce7aa668833f8a4e2ff"></a><!-- doxytag: member="cuddGenCof.c::Cudd_SupersetCompress" ref="a194308bd7e4afce7aa668833f8a4e2ff" args="(DdManager *dd, DdNode *f, int nvars, int threshold)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_SupersetCompress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nvars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find a dense superset of BDD `f`. </p>
<p>Density is the ratio of number of minterms to number of nodes. Uses several techniques in series. It is more expensive than other supersetting procedures, but often produces better results. See Cudd_SupersetShortPaths for a description of the threshold and nvars parameters.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the result if successful; NULL otherwise.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddGenCof_8c.html#abbc5a582b85170a4c365e852b98c37da" title="Find a dense subset of BDD `f`.">Cudd_SubsetCompress</a> Cudd_SupersetRemap <a class="el" href="cuddSubsetSP_8c.html#a64d8ed34596ee3ef413bc804f08de8f7" title="Extracts a dense superset from a BDD with the shortest paths heuristic.">Cudd_SupersetShortPaths</a> <a class="el" href="cuddSubsetHB_8c.html#a5562f42d8ed481485bcb9d5469b2cedd" title="Extracts a dense superset from a BDD with the heavy branch heuristic.">Cudd_SupersetHeavyBranch</a> <a class="el" href="cuddGenCof_8c.html#afbc2329b3d7a6cb0b8adc5582fc7fe2c" title="Finds a small BDD in a function interval.">Cudd_bddSqueeze</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>BDD whose superset is sought </td></tr>
    <tr><td class="paramname">nvars</td><td>number of variables in the support of f </td></tr>
    <tr><td class="paramname">threshold</td><td>maximum number of nodes in the superset </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abb45bdb200e1e4e975b20925130a6c66"></a><!-- doxytag: member="cuddGenCof.c::cuddAddConstrainRecur" ref="abb45bdb200e1e4e975b20925130a6c66" args="(DdManager *dd, DdNode *f, DdNode *c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* cuddAddConstrainRecur </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs the recursive step of Cudd_addConstrain. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the result if successful; NULL otherwise.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddGenCof_8c.html#a3bdc53bb832fb6b57528e7d5ceef7944" title="Computes f constrain c for ADDs.">Cudd_addConstrain</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a560239ea1d3da12ff14b214f0adf17a4"></a><!-- doxytag: member="cuddGenCof.c::cuddAddRestrictRecur" ref="a560239ea1d3da12ff14b214f0adf17a4" args="(DdManager *dd, DdNode *f, DdNode *c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* cuddAddRestrictRecur </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs the recursive step of Cudd_addRestrict. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the restricted ADD if successful; otherwise NULL.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddGenCof_8c.html#a4ab16f58da620eb1c2e927426aea22c7" title="ADD restrict according to Coudert and Madre&#39;s algorithm (ICCAD90).">Cudd_addRestrict</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a544d6fe00d57c345745125eb2f426269"></a><!-- doxytag: member="cuddGenCof.c::cuddBddCharToVect" ref="a544d6fe00d57c345745125eb2f426269" args="(DdManager *dd, DdNode *f, DdNode *x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structDdNode.html">DdNode</a>* cuddBddCharToVect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs the recursive step of Cudd_bddCharToVect. </p>
<p>This function maintains the invariant that f is non-zero.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the i-th component of the vector if successful; otherwise NULL.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddGenCof_8c.html#a1a4482b94e76db44ff22087277d09b4d" title="Computes a vector of BDDs whose image equals a non-zero function.">Cudd_bddCharToVect</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a5eaea32f6ed375be93c707ce4f5fea3d"></a><!-- doxytag: member="cuddGenCof.c::cuddBddConstrainDecomp" ref="a5eaea32f6ed375be93c707ce4f5fea3d" args="(DdManager *dd, DdNode *f, DdNode **decomp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int cuddBddConstrainDecomp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>decomp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs the recursive step of Cudd_bddConstrainDecomp. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>f super (i) if successful; otherwise NULL.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddGenCof_8c.html#aaaf0b345123f5065ac6b2ea951b7bfe8" title="BDD conjunctive decomposition as in McMillan&#39;s CAV96 paper.">Cudd_bddConstrainDecomp</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6311f1cc598ee0f3681a76baec8c6d53"></a><!-- doxytag: member="cuddGenCof.c::cuddBddConstrainRecur" ref="a6311f1cc598ee0f3681a76baec8c6d53" args="(DdManager *dd, DdNode *f, DdNode *c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* cuddBddConstrainRecur </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs the recursive step of Cudd_bddConstrain. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the result if successful; NULL otherwise.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddGenCof_8c.html#a250f801a2e5814da9d67a3436f0e3376" title="Computes f constrain c.">Cudd_bddConstrain</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aea13cdf4c9cef5ded81a6fd74c21ce2d"></a><!-- doxytag: member="cuddGenCof.c::cuddBddInterpolate" ref="aea13cdf4c9cef5ded81a6fd74c21ce2d" args="(DdManager *dd, DdNode *l, DdNode *u)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structDdNode.html">DdNode</a>* cuddBddInterpolate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs the recursive step of Cudd_bddInterpolate. </p>
<p>This procedure exploits the fact that if we complement and swap the bounds of the interval we obtain a valid solution by taking the complement of the solution to the original problem. Therefore, we can enforce the condition that the upper bound is always regular.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the result if successful; NULL otherwise.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddGenCof_8c.html#aee71bb03723625bacf2c0b369a187125" title="Finds an interpolant of two functions.">Cudd_bddInterpolate</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a030d33ea12ccc3211150fb6a56899bd3"></a><!-- doxytag: member="cuddGenCof.c::cuddBddLICBuildResult" ref="a030d33ea12ccc3211150fb6a56899bd3" args="(DdManager *dd, DdNode *f, st_table *cache, st_table *table)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structDdNode.html">DdNode</a>* cuddBddLICBuildResult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__table.html">st_table</a> *&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__table.html">st_table</a> *&#160;</td>
          <td class="paramname"><em>table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds the result of Cudd_bddLICompaction. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the minimized BDD if successful; otherwise NULL.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddGenCof_8c.html#a6c23e53c189d45d06b68a9a52b724141" title="Performs safe minimization of a BDD.">Cudd_bddLICompaction</a> <a class="el" href="cuddGenCof_8c.html#a6816dc82d29be25bac7eec5068866537" title="Performs the edge marking step of Cudd_bddLICompaction.">cuddBddLICMarkEdges</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6816dc82d29be25bac7eec5068866537"></a><!-- doxytag: member="cuddGenCof.c::cuddBddLICMarkEdges" ref="a6816dc82d29be25bac7eec5068866537" args="(DdManager *dd, DdNode *f, DdNode *c, st_table *table, st_table *cache)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int cuddBddLICMarkEdges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__table.html">st_table</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__table.html">st_table</a> *&#160;</td>
          <td class="paramname"><em>cache</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs the edge marking step of Cudd_bddLICompaction. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the LUB of the markings of the two outgoing edges of <code>f</code> if successful; otherwise CUDD_OUT_OF_MEM.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddGenCof_8c.html#a6c23e53c189d45d06b68a9a52b724141" title="Performs safe minimization of a BDD.">Cudd_bddLICompaction</a> <a class="el" href="cuddGenCof_8c.html#a030d33ea12ccc3211150fb6a56899bd3" title="Builds the result of Cudd_bddLICompaction.">cuddBddLICBuildResult</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6ac4647d91d277c68197d1860239dfbc"></a><!-- doxytag: member="cuddGenCof.c::cuddBddLICompaction" ref="a6ac4647d91d277c68197d1860239dfbc" args="(DdManager *dd, DdNode *f, DdNode *c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* cuddBddLICompaction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs safe minimization of a BDD. </p>
<p>Given the BDD `f` of a function to be minimized and a BDD `c` representing the care set, Cudd_bddLICompaction produces the BDD of a function that agrees with `f` wherever `c` is 1. Safe minimization means that the size of the result is guaranteed not to exceed the size of `f`. This function is based on the DAC97 paper by Hong et al..</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the result if successful; NULL otherwise.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddGenCof_8c.html#a6c23e53c189d45d06b68a9a52b724141" title="Performs safe minimization of a BDD.">Cudd_bddLICompaction</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>manager </td></tr>
    <tr><td class="paramname">f</td><td>function to be minimized </td></tr>
    <tr><td class="paramname">c</td><td>constraint (care set) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acf9e01bcb80c9d9fb11db7409de68638"></a><!-- doxytag: member="cuddGenCof.c::cuddBddNPAndRecur" ref="acf9e01bcb80c9d9fb11db7409de68638" args="(DdManager *manager, DdNode *f, DdNode *g)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* cuddBddNPAndRecur </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements the recursive step of Cudd_bddAnd. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the result is successful; NULL otherwise.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddGenCof_8c.html#ab2c68fd99c5b8c0c854c0ba2f1944d39" title="Computes f non-polluting-and g.">Cudd_bddNPAnd</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac7fd377dc8f0df6472ca0fe6df41ae48"></a><!-- doxytag: member="cuddGenCof.c::cuddBddRestrictRecur" ref="ac7fd377dc8f0df6472ca0fe6df41ae48" args="(DdManager *dd, DdNode *f, DdNode *c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* cuddBddRestrictRecur </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs the recursive step of Cudd_bddRestrict. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the restricted BDD if successful; otherwise NULL.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddGenCof_8c.html#a3c8d8bb0210e368eb7258b2961c3cf3e" title="BDD restrict according to Coudert and Madre&#39;s algorithm (ICCAD90).">Cudd_bddRestrict</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a95af9893c405bea9e49dba8632e8abb3"></a><!-- doxytag: member="cuddGenCof.c::cuddBddSqueeze" ref="a95af9893c405bea9e49dba8632e8abb3" args="(DdManager *dd, DdNode *l, DdNode *u)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structDdNode.html">DdNode</a>* cuddBddSqueeze </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs the recursive step of Cudd_bddSqueeze. </p>
<p>This procedure exploits the fact that if we complement and swap the bounds of the interval we obtain a valid solution by taking the complement of the solution to the original problem. Therefore, we can enforce the condition that the upper bound is always regular.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the result if successful; NULL otherwise.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddGenCof_8c.html#afbc2329b3d7a6cb0b8adc5582fc7fe2c" title="Finds a small BDD in a function interval.">Cudd_bddSqueeze</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a90b8f5db40b9678f92372dbbac47f75b"></a><!-- doxytag: member="cuddGenCof.c::MarkCacheCleanUp" ref="a90b8f5db40b9678f92372dbbac47f75b" args="(void *key, void *value, void *arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static enum <a class="el" href="st_8h.html#a0c6a172fd99de7928916e65034ed8b1f">st_retval</a> MarkCacheCleanUp </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Frees memory associated with computed table of cuddBddLICMarkEdges. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>ST_CONTINUE.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddGenCof_8c.html#a6c23e53c189d45d06b68a9a52b724141" title="Performs safe minimization of a BDD.">Cudd_bddLICompaction</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a29d7cf50fd4deeffde8d28af9fd15ecb"></a><!-- doxytag: member="cuddGenCof.c::MarkCacheCompare" ref="a29d7cf50fd4deeffde8d28af9fd15ecb" args="(const void *ptr1, const void *ptr2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int MarkCacheCompare </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ptr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ptr2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Comparison function for the computed table of cuddBddLICMarkEdges. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the two nodes of the key are equal; 1 otherwise.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddGenCof_8c.html#a6c23e53c189d45d06b68a9a52b724141" title="Performs safe minimization of a BDD.">Cudd_bddLICompaction</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac56ab0c42e8725d6bb14715af44a2e65"></a><!-- doxytag: member="cuddGenCof.c::MarkCacheHash" ref="ac56ab0c42e8725d6bb14715af44a2e65" args="(void const *ptr, int modulus)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int MarkCacheHash </td>
          <td>(</td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>modulus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Hash function for the computed table of cuddBddLICMarkEdges. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the bucket number.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddGenCof_8c.html#a6c23e53c189d45d06b68a9a52b724141" title="Performs safe minimization of a BDD.">Cudd_bddLICompaction</a> </dd></dl>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Thu May 12 2022 22:59:10 for cudd by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
