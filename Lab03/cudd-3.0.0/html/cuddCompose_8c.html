<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>cudd: cudd/cuddCompose.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">cudd&#160;<span id="projectnumber">3.0.0</span></div>
   <div id="projectbrief">The University of Colorado Decision Diagram Package</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>cudd/cuddCompose.c File Reference<div class="ingroups"><a class="el" href="group__cudd.html">cudd</a></div></h1>  </div>
</div>
<div class="contents">

<p>Functional composition and variable permutation of DDs.  
<a href="#_details">More...</a></p>
<div class="textblock"><code>#include &quot;util.h&quot;</code><br/>
<code>#include &quot;<a class="el" href="cuddInt_8h_source.html">cuddInt.h</a>&quot;</code><br/>
</div><div class="textblock"><div class="dynheader">
Include dependency graph for cuddCompose.c:</div>
<div class="dyncontent">
<div class="center"><img src="cuddCompose_8c__incl.png" border="0" usemap="#cudd_2cuddCompose_8c" alt=""/></div>
<map name="cudd_2cuddCompose_8c" id="cudd_2cuddCompose_8c">
<area shape="rect" id="node3" href="cuddInt_8h.html" title="Internal data structures of the CUDD package." alt="" coords="239,80,315,107"/><area shape="rect" id="node5" href="config_8h_source.html" title="config.h" alt="" coords="91,155,159,181"/><area shape="rect" id="node9" href="cudd_8h.html" title="The University of Colorado decision diagram package." alt="" coords="407,155,468,181"/></map>
</div>
</div><table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddCompose_8c.html#ab5ccb7b9d27d9d383d0f407cf894f118">Cudd_bddCompose</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *g, int v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitutes g for x_v in the BDD for f.  <a href="#ab5ccb7b9d27d9d383d0f407cf894f118"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddCompose_8c.html#ad050bd964c7386f2a9eed09b8a1d25d7">Cudd_addCompose</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *g, int v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitutes g for x_v in the ADD for f.  <a href="#ad050bd964c7386f2a9eed09b8a1d25d7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddCompose_8c.html#a4926a513ab721d9bbc866740d40cbfcf">Cudd_addPermute</a> (<a class="el" href="structDdManager.html">DdManager</a> *manager, <a class="el" href="structDdNode.html">DdNode</a> *node, int *permut)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Permutes the variables of an ADD.  <a href="#a4926a513ab721d9bbc866740d40cbfcf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddCompose_8c.html#a2ab066ce29ac83aa7d3891b96d4356e1">Cudd_addSwapVariables</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> **x, <a class="el" href="structDdNode.html">DdNode</a> **y, int n)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps two sets of variables of the same size (x and y) in the ADD f.  <a href="#a2ab066ce29ac83aa7d3891b96d4356e1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddCompose_8c.html#afa877bf86c670ea10d67d4f6e91fcc98">Cudd_bddPermute</a> (<a class="el" href="structDdManager.html">DdManager</a> *manager, <a class="el" href="structDdNode.html">DdNode</a> *node, int *permut)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Permutes the variables of a BDD.  <a href="#afa877bf86c670ea10d67d4f6e91fcc98"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddCompose_8c.html#af1b6ff390b8f205a28d2804d723118d9">Cudd_bddVarMap</a> (<a class="el" href="structDdManager.html">DdManager</a> *manager, <a class="el" href="structDdNode.html">DdNode</a> *f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Remaps the variables of a BDD using the default variable map.  <a href="#af1b6ff390b8f205a28d2804d723118d9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddCompose_8c.html#a3d0ed2b9c7a7158ed78273908a2a5386">Cudd_SetVarMap</a> (<a class="el" href="structDdManager.html">DdManager</a> *manager, <a class="el" href="structDdNode.html">DdNode</a> **x, <a class="el" href="structDdNode.html">DdNode</a> **y, int n)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a variable mapping with the manager.  <a href="#a3d0ed2b9c7a7158ed78273908a2a5386"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddCompose_8c.html#a2ab6b6123e102f9b0b61c9d2961f707e">Cudd_bddSwapVariables</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> **x, <a class="el" href="structDdNode.html">DdNode</a> **y, int n)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps two sets of variables of the same size (x and y) in the BDD f.  <a href="#a2ab6b6123e102f9b0b61c9d2961f707e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddCompose_8c.html#a6e976b573531badb9a023f86dcdbeb40">Cudd_bddAdjPermuteX</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *B, <a class="el" href="structDdNode.html">DdNode</a> **x, int n)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Rearranges a set of variables in the BDD B.  <a href="#a6e976b573531badb9a023f86dcdbeb40"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddCompose_8c.html#a62543c529dab3780047f2a45f1e5c50f">Cudd_addVectorCompose</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> **vector)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Composes an ADD with a vector of 0-1 ADDs.  <a href="#a62543c529dab3780047f2a45f1e5c50f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddCompose_8c.html#a0d52f7db30965ff17d5a8d5667162eb5">Cudd_addGeneralVectorCompose</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> **vectorOn, <a class="el" href="structDdNode.html">DdNode</a> **vectorOff)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Composes an ADD with a vector of ADDs.  <a href="#a0d52f7db30965ff17d5a8d5667162eb5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddCompose_8c.html#a74339b069aaea8dbf1b321eaa773b59a">Cudd_addNonSimCompose</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> **vector)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Composes an ADD with a vector of 0-1 ADDs.  <a href="#a74339b069aaea8dbf1b321eaa773b59a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddCompose_8c.html#a0bffb3a79510753ee6648a998aaaae97">Cudd_bddVectorCompose</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> **vector)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Composes a BDD with a vector of BDDs.  <a href="#a0bffb3a79510753ee6648a998aaaae97"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddCompose_8c.html#a133d2162f21001ffd87160c1ba9ee761">cuddBddComposeRecur</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *g, <a class="el" href="structDdNode.html">DdNode</a> *proj)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the recursive step of Cudd_bddCompose.  <a href="#a133d2162f21001ffd87160c1ba9ee761"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddCompose_8c.html#a13d26ec582df94635299038b44d4cb4b">cuddAddComposeRecur</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *g, <a class="el" href="structDdNode.html">DdNode</a> *proj)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the recursive step of Cudd_addCompose.  <a href="#a13d26ec582df94635299038b44d4cb4b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddCompose_8c.html#ab5857292c431da5fa962b23c0ccabda2">cuddAddPermuteRecur</a> (<a class="el" href="structDdManager.html">DdManager</a> *manager, <a class="el" href="structDdHashTable.html">DdHashTable</a> *table, <a class="el" href="structDdNode.html">DdNode</a> *node, int *permut)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the recursive step of Cudd_addPermute.  <a href="#ab5857292c431da5fa962b23c0ccabda2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddCompose_8c.html#aafe391f4d9382e7ac57e6bfae5d35eab">cuddBddPermuteRecur</a> (<a class="el" href="structDdManager.html">DdManager</a> *manager, <a class="el" href="structDdHashTable.html">DdHashTable</a> *table, <a class="el" href="structDdNode.html">DdNode</a> *node, int *permut)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the recursive step of Cudd_bddPermute.  <a href="#aafe391f4d9382e7ac57e6bfae5d35eab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddCompose_8c.html#a82e75c6dca2c43fb15035c0411b6342d">cuddBddVarMapRecur</a> (<a class="el" href="structDdManager.html">DdManager</a> *manager, <a class="el" href="structDdNode.html">DdNode</a> *f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the recursive step of Cudd_bddVarMap.  <a href="#a82e75c6dca2c43fb15035c0411b6342d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddCompose_8c.html#a0724509f334eefd7b42fb863960fd5ce">cuddAddVectorComposeRecur</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdHashTable.html">DdHashTable</a> *table, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> **vector, int deepest)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the recursive step of Cudd_addVectorCompose.  <a href="#a0724509f334eefd7b42fb863960fd5ce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddCompose_8c.html#aaad7d5fdbf314bcbb22d0a7f04b63148">cuddAddGeneralVectorComposeRecur</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdHashTable.html">DdHashTable</a> *table, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> **vectorOn, <a class="el" href="structDdNode.html">DdNode</a> **vectorOff, int deepest)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the recursive step of Cudd_addGeneralVectorCompose.  <a href="#aaad7d5fdbf314bcbb22d0a7f04b63148"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddCompose_8c.html#ac5bad014827255f25a62c401df4dbd8b">cuddAddNonSimComposeRecur</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> **vector, <a class="el" href="structDdNode.html">DdNode</a> *key, <a class="el" href="structDdNode.html">DdNode</a> *cube, int lastsub)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the recursive step of Cudd_addNonSimCompose.  <a href="#ac5bad014827255f25a62c401df4dbd8b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structDdNode.html">DdNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddCompose_8c.html#a79955dcae643990f810d79bf93fe1f72">cuddBddVectorComposeRecur</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdHashTable.html">DdHashTable</a> *table, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> **vector, int deepest)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the recursive step of Cudd_bddVectorCompose.  <a href="#a79955dcae643990f810d79bf93fe1f72"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddCompose_8c.html#aba2fa818c76d5302d83929ee4402da39">ddIsIthAddVar</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, unsigned int i)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison of a function to the i-th ADD variable.  <a href="#aba2fa818c76d5302d83929ee4402da39"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddCompose_8c.html#af318178b1f1071db47c7e268673b6631">ddIsIthAddVarPair</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *g, unsigned int i)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison of a pair of functions to the i-th ADD variable.  <a href="#af318178b1f1071db47c7e268673b6631"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Functional composition and variable permutation of DDs. </p>
<p>The permutation functions use a local cache because the results to be remembered depend on the permutation being applied. Since the permutation is just an array, it cannot be stored in the global cache. There are different procedured for BDDs and ADDs. This is because bddPermuteRecur uses cuddBddIteRecur. If this were changed, the procedures could be merged.</p>
<dl class="author"><dt><b>Author:</b></dt><dd>Fabio Somenzi and Kavita Ravi</dd></dl>
<p>Copyright (c) 1995-2015, Regents of the University of Colorado</p>
<p>All rights reserved.</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p>
<p>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</p>
<p>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</p>
<p>Neither the name of the University of Colorado nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</p>
<p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  </p>
</div><hr/><h2>Function Documentation</h2>
<a class="anchor" id="ad050bd964c7386f2a9eed09b8a1d25d7"></a><!-- doxytag: member="cuddCompose.c::Cudd_addCompose" ref="ad050bd964c7386f2a9eed09b8a1d25d7" args="(DdManager *dd, DdNode *f, DdNode *g, int v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_addCompose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Substitutes g for x_v in the ADD for f. </p>
<p>v is the index of the variable to be substituted. g must be a 0-1 ADD. Cudd_bddCompose passes the corresponding projection function to the recursive procedure, so that the cache may be used.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the composed ADD if successful; NULL otherwise.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddCompose_8c.html#ab5ccb7b9d27d9d383d0f407cf894f118" title="Substitutes g for x_v in the BDD for f.">Cudd_bddCompose</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0d52f7db30965ff17d5a8d5667162eb5"></a><!-- doxytag: member="cuddCompose.c::Cudd_addGeneralVectorCompose" ref="a0d52f7db30965ff17d5a8d5667162eb5" args="(DdManager *dd, DdNode *f, DdNode **vectorOn, DdNode **vectorOff)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_addGeneralVectorCompose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>vectorOn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>vectorOff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Composes an ADD with a vector of ADDs. </p>
<p>Given a vector of ADDs, creates a new ADD by substituting the ADDs for the variables of the ADD f. vectorOn contains ADDs to be substituted for the x_v and vectorOff the ADDs to be substituted for x_v'. There should be an entry in vector for each variable in the manager. If no substitution is sought for a given variable, the corresponding projection function should be specified in the vector. This function implements simultaneous composition.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the resulting ADD if successful; NULL otherwise.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddCompose_8c.html#a62543c529dab3780047f2a45f1e5c50f" title="Composes an ADD with a vector of 0-1 ADDs.">Cudd_addVectorCompose</a> <a class="el" href="cuddCompose_8c.html#a74339b069aaea8dbf1b321eaa773b59a" title="Composes an ADD with a vector of 0-1 ADDs.">Cudd_addNonSimCompose</a> <a class="el" href="cuddCompose_8c.html#a4926a513ab721d9bbc866740d40cbfcf" title="Permutes the variables of an ADD.">Cudd_addPermute</a> <a class="el" href="cuddCompose_8c.html#ad050bd964c7386f2a9eed09b8a1d25d7" title="Substitutes g for x_v in the ADD for f.">Cudd_addCompose</a> <a class="el" href="cuddCompose_8c.html#a0bffb3a79510753ee6648a998aaaae97" title="Composes a BDD with a vector of BDDs.">Cudd_bddVectorCompose</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a74339b069aaea8dbf1b321eaa773b59a"></a><!-- doxytag: member="cuddCompose.c::Cudd_addNonSimCompose" ref="a74339b069aaea8dbf1b321eaa773b59a" args="(DdManager *dd, DdNode *f, DdNode **vector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_addNonSimCompose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Composes an ADD with a vector of 0-1 ADDs. </p>
<p>Given a vector of 0-1 ADDs, creates a new ADD by substituting the 0-1 ADDs for the variables of the ADD f. There should be an entry in vector for each variable in the manager. This function implements non-simultaneous composition. If any of the functions being composed depends on any of the variables being substituted, then the result depends on the order of composition, which in turn depends on the variable order: The variables farther from the roots in the order are substituted first.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the resulting ADD if successful; NULL otherwise.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddCompose_8c.html#a62543c529dab3780047f2a45f1e5c50f" title="Composes an ADD with a vector of 0-1 ADDs.">Cudd_addVectorCompose</a> <a class="el" href="cuddCompose_8c.html#a4926a513ab721d9bbc866740d40cbfcf" title="Permutes the variables of an ADD.">Cudd_addPermute</a> <a class="el" href="cuddCompose_8c.html#ad050bd964c7386f2a9eed09b8a1d25d7" title="Substitutes g for x_v in the ADD for f.">Cudd_addCompose</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4926a513ab721d9bbc866740d40cbfcf"></a><!-- doxytag: member="cuddCompose.c::Cudd_addPermute" ref="a4926a513ab721d9bbc866740d40cbfcf" args="(DdManager *manager, DdNode *node, int *permut)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_addPermute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>permut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Permutes the variables of an ADD. </p>
<p>Given a permutation in array permut, creates a new ADD with permuted variables. There should be an entry in array permut for each variable in the manager. The i-th entry of permut holds the index of the variable that is to substitute the i-th variable.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the resulting ADD if successful; NULL otherwise.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddCompose_8c.html#afa877bf86c670ea10d67d4f6e91fcc98" title="Permutes the variables of a BDD.">Cudd_bddPermute</a> <a class="el" href="cuddCompose_8c.html#a2ab066ce29ac83aa7d3891b96d4356e1" title="Swaps two sets of variables of the same size (x and y) in the ADD f.">Cudd_addSwapVariables</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2ab066ce29ac83aa7d3891b96d4356e1"></a><!-- doxytag: member="cuddCompose.c::Cudd_addSwapVariables" ref="a2ab066ce29ac83aa7d3891b96d4356e1" args="(DdManager *dd, DdNode *f, DdNode **x, DdNode **y, int n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_addSwapVariables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Swaps two sets of variables of the same size (x and y) in the ADD f. </p>
<p>The size is given by n. The two sets of variables are assumed to be disjoint.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the resulting ADD if successful; NULL otherwise.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddCompose_8c.html#a4926a513ab721d9bbc866740d40cbfcf" title="Permutes the variables of an ADD.">Cudd_addPermute</a> <a class="el" href="cuddCompose_8c.html#a2ab6b6123e102f9b0b61c9d2961f707e" title="Swaps two sets of variables of the same size (x and y) in the BDD f.">Cudd_bddSwapVariables</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a62543c529dab3780047f2a45f1e5c50f"></a><!-- doxytag: member="cuddCompose.c::Cudd_addVectorCompose" ref="a62543c529dab3780047f2a45f1e5c50f" args="(DdManager *dd, DdNode *f, DdNode **vector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_addVectorCompose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Composes an ADD with a vector of 0-1 ADDs. </p>
<p>Given a vector of 0-1 ADDs, creates a new ADD by substituting the 0-1 ADDs for the variables of the ADD f. There should be an entry in vector for each variable in the manager. If no substitution is sought for a given variable, the corresponding projection function should be specified in the vector. This function implements simultaneous composition.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the resulting ADD if successful; NULL otherwise.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddCompose_8c.html#a74339b069aaea8dbf1b321eaa773b59a" title="Composes an ADD with a vector of 0-1 ADDs.">Cudd_addNonSimCompose</a> <a class="el" href="cuddCompose_8c.html#a4926a513ab721d9bbc866740d40cbfcf" title="Permutes the variables of an ADD.">Cudd_addPermute</a> <a class="el" href="cuddCompose_8c.html#ad050bd964c7386f2a9eed09b8a1d25d7" title="Substitutes g for x_v in the ADD for f.">Cudd_addCompose</a> <a class="el" href="cuddCompose_8c.html#a0bffb3a79510753ee6648a998aaaae97" title="Composes a BDD with a vector of BDDs.">Cudd_bddVectorCompose</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6e976b573531badb9a023f86dcdbeb40"></a><!-- doxytag: member="cuddCompose.c::Cudd_bddAdjPermuteX" ref="a6e976b573531badb9a023f86dcdbeb40" args="(DdManager *dd, DdNode *B, DdNode **x, int n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddAdjPermuteX </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rearranges a set of variables in the BDD B. </p>
<p>The size of the set is given by n. This procedure is intended for the `randomization' of the priority functions.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the BDD if successful; NULL otherwise.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddCompose_8c.html#afa877bf86c670ea10d67d4f6e91fcc98" title="Permutes the variables of a BDD.">Cudd_bddPermute</a> <a class="el" href="cuddCompose_8c.html#a2ab6b6123e102f9b0b61c9d2961f707e" title="Swaps two sets of variables of the same size (x and y) in the BDD f.">Cudd_bddSwapVariables</a> <a class="el" href="cuddPriority_8c.html#a7ee4055f67c91825ec6edbea00ce9f83" title="Generates a BDD for the function d(x,y) &gt; d(x,z).">Cudd_Dxygtdxz</a> <a class="el" href="cuddPriority_8c.html#ab118ad9c8350d51d5ce1b824db5423fd" title="Generates a BDD for the function d(x,y) &gt; d(y,z).">Cudd_Dxygtdyz</a> <a class="el" href="cuddPriority_8c.html#a939056ced12b4b1d25ea97279b35f941" title="Selects pairs from R using a priority function.">Cudd_PrioritySelect</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab5ccb7b9d27d9d383d0f407cf894f118"></a><!-- doxytag: member="cuddCompose.c::Cudd_bddCompose" ref="ab5ccb7b9d27d9d383d0f407cf894f118" args="(DdManager *dd, DdNode *f, DdNode *g, int v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddCompose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Substitutes g for x_v in the BDD for f. </p>
<p>v is the index of the variable to be substituted. Cudd_bddCompose passes the corresponding projection function to the recursive procedure, so that the cache may be used.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the composed BDD if successful; NULL otherwise.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddCompose_8c.html#ad050bd964c7386f2a9eed09b8a1d25d7" title="Substitutes g for x_v in the ADD for f.">Cudd_addCompose</a> </dd></dl>

</div>
</div>
<a class="anchor" id="afa877bf86c670ea10d67d4f6e91fcc98"></a><!-- doxytag: member="cuddCompose.c::Cudd_bddPermute" ref="afa877bf86c670ea10d67d4f6e91fcc98" args="(DdManager *manager, DdNode *node, int *permut)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddPermute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>permut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Permutes the variables of a BDD. </p>
<p>Given a permutation in array permut, creates a new BDD with permuted variables. There should be an entry in array permut for each variable in the manager. The i-th entry of permut holds the index of the variable that is to substitute the i-th variable.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the resulting BDD if successful; NULL otherwise.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddCompose_8c.html#a4926a513ab721d9bbc866740d40cbfcf" title="Permutes the variables of an ADD.">Cudd_addPermute</a> <a class="el" href="cuddCompose_8c.html#a2ab6b6123e102f9b0b61c9d2961f707e" title="Swaps two sets of variables of the same size (x and y) in the BDD f.">Cudd_bddSwapVariables</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2ab6b6123e102f9b0b61c9d2961f707e"></a><!-- doxytag: member="cuddCompose.c::Cudd_bddSwapVariables" ref="a2ab6b6123e102f9b0b61c9d2961f707e" args="(DdManager *dd, DdNode *f, DdNode **x, DdNode **y, int n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddSwapVariables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Swaps two sets of variables of the same size (x and y) in the BDD f. </p>
<p>The size is given by n. The two sets of variables are assumed to be disjoint.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the resulting BDD if successful; NULL otherwise.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddCompose_8c.html#afa877bf86c670ea10d67d4f6e91fcc98" title="Permutes the variables of a BDD.">Cudd_bddPermute</a> <a class="el" href="cuddCompose_8c.html#a2ab066ce29ac83aa7d3891b96d4356e1" title="Swaps two sets of variables of the same size (x and y) in the ADD f.">Cudd_addSwapVariables</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af1b6ff390b8f205a28d2804d723118d9"></a><!-- doxytag: member="cuddCompose.c::Cudd_bddVarMap" ref="af1b6ff390b8f205a28d2804d723118d9" args="(DdManager *manager, DdNode *f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddVarMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remaps the variables of a BDD using the default variable map. </p>
<p>A typical use of this function is to swap two sets of variables. The variable map must be registered with Cudd_SetVarMap.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the resulting BDD if successful; NULL otherwise.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddCompose_8c.html#afa877bf86c670ea10d67d4f6e91fcc98" title="Permutes the variables of a BDD.">Cudd_bddPermute</a> <a class="el" href="cuddCompose_8c.html#a2ab6b6123e102f9b0b61c9d2961f707e" title="Swaps two sets of variables of the same size (x and y) in the BDD f.">Cudd_bddSwapVariables</a> <a class="el" href="cuddCompose_8c.html#a3d0ed2b9c7a7158ed78273908a2a5386" title="Registers a variable mapping with the manager.">Cudd_SetVarMap</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">manager</td><td>DD manager </td></tr>
    <tr><td class="paramname">f</td><td>function in which to remap variables </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0bffb3a79510753ee6648a998aaaae97"></a><!-- doxytag: member="cuddCompose.c::Cudd_bddVectorCompose" ref="a0bffb3a79510753ee6648a998aaaae97" args="(DdManager *dd, DdNode *f, DdNode **vector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_bddVectorCompose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Composes a BDD with a vector of BDDs. </p>
<p>Given a vector of BDDs, creates a new BDD by substituting the BDDs for the variables of the BDD f. There should be an entry in vector for each variable in the manager. If no substitution is sought for a given variable, the corresponding projection function should be specified in the vector. This function implements simultaneous composition.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the resulting BDD if successful; NULL otherwise.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddCompose_8c.html#afa877bf86c670ea10d67d4f6e91fcc98" title="Permutes the variables of a BDD.">Cudd_bddPermute</a> <a class="el" href="cuddCompose_8c.html#ab5ccb7b9d27d9d383d0f407cf894f118" title="Substitutes g for x_v in the BDD for f.">Cudd_bddCompose</a> <a class="el" href="cuddCompose_8c.html#a62543c529dab3780047f2a45f1e5c50f" title="Composes an ADD with a vector of 0-1 ADDs.">Cudd_addVectorCompose</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3d0ed2b9c7a7158ed78273908a2a5386"></a><!-- doxytag: member="cuddCompose.c::Cudd_SetVarMap" ref="a3d0ed2b9c7a7158ed78273908a2a5386" args="(DdManager *manager, DdNode **x, DdNode **y, int n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Cudd_SetVarMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Registers a variable mapping with the manager. </p>
<p>Registers with the manager a variable mapping described by two sets of variables. This variable mapping is then used by functions like Cudd_bddVarMap. This function is convenient for those applications that perform the same mapping several times. However, if several different permutations are used, it may be more efficient not to rely on the registered mapping, because changing mapping causes the cache to be cleared. (The initial setting, however, does not clear the cache.) The two sets of variables (x and y) must have the same size (x and y). The size is given by n. The two sets of variables are normally disjoint, but this restriction is not imposeded by the function. When new variables are created, the map is automatically extended (each new variable maps to itself). The typical use, however, is to wait until all variables are created, and then create the map.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if the mapping is successfully registered with the manager; 0 otherwise.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>Modifies the manager. May clear the cache.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddCompose_8c.html#af1b6ff390b8f205a28d2804d723118d9" title="Remaps the variables of a BDD using the default variable map.">Cudd_bddVarMap</a> <a class="el" href="cuddCompose_8c.html#afa877bf86c670ea10d67d4f6e91fcc98" title="Permutes the variables of a BDD.">Cudd_bddPermute</a> <a class="el" href="cuddCompose_8c.html#a2ab6b6123e102f9b0b61c9d2961f707e" title="Swaps two sets of variables of the same size (x and y) in the BDD f.">Cudd_bddSwapVariables</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">manager</td><td>DD manager </td></tr>
    <tr><td class="paramname">x</td><td>first array of variables </td></tr>
    <tr><td class="paramname">y</td><td>second array of variables </td></tr>
    <tr><td class="paramname">n</td><td>length of both arrays </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a13d26ec582df94635299038b44d4cb4b"></a><!-- doxytag: member="cuddCompose.c::cuddAddComposeRecur" ref="a13d26ec582df94635299038b44d4cb4b" args="(DdManager *dd, DdNode *f, DdNode *g, DdNode *proj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* cuddAddComposeRecur </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>proj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs the recursive step of Cudd_addCompose. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the composed BDD if successful; NULL otherwise.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddCompose_8c.html#ad050bd964c7386f2a9eed09b8a1d25d7" title="Substitutes g for x_v in the ADD for f.">Cudd_addCompose</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aaad7d5fdbf314bcbb22d0a7f04b63148"></a><!-- doxytag: member="cuddCompose.c::cuddAddGeneralVectorComposeRecur" ref="aaad7d5fdbf314bcbb22d0a7f04b63148" args="(DdManager *dd, DdHashTable *table, DdNode *f, DdNode **vectorOn, DdNode **vectorOff, int deepest)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structDdNode.html">DdNode</a>* cuddAddGeneralVectorComposeRecur </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdHashTable.html">DdHashTable</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>vectorOn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>vectorOff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>deepest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs the recursive step of Cudd_addGeneralVectorCompose. </p>
<dl class="user"><dt><b>Side effects</b></dt><dd>None </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>DD manager </td></tr>
    <tr><td class="paramname">table</td><td>computed table </td></tr>
    <tr><td class="paramname">f</td><td>ADD in which to compose </td></tr>
    <tr><td class="paramname">vectorOn</td><td>functions to substitute for x_i </td></tr>
    <tr><td class="paramname">vectorOff</td><td>functions to substitute for x_i' </td></tr>
    <tr><td class="paramname">deepest</td><td>depth of deepest substitution </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac5bad014827255f25a62c401df4dbd8b"></a><!-- doxytag: member="cuddCompose.c::cuddAddNonSimComposeRecur" ref="ac5bad014827255f25a62c401df4dbd8b" args="(DdManager *dd, DdNode *f, DdNode **vector, DdNode *key, DdNode *cube, int lastsub)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structDdNode.html">DdNode</a>* cuddAddNonSimComposeRecur </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>cube</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lastsub</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs the recursive step of Cudd_addNonSimCompose. </p>
<dl class="user"><dt><b>Side effects</b></dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ab5857292c431da5fa962b23c0ccabda2"></a><!-- doxytag: member="cuddCompose.c::cuddAddPermuteRecur" ref="ab5857292c431da5fa962b23c0ccabda2" args="(DdManager *manager, DdHashTable *table, DdNode *node, int *permut)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structDdNode.html">DdNode</a>* cuddAddPermuteRecur </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdHashTable.html">DdHashTable</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>permut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements the recursive step of Cudd_addPermute. </p>
<p>Recursively puts the ADD in the order given in the array permut. Checks for trivial cases to terminate recursion, then splits on the children of this node. Once the solutions for the children are obtained, it puts into the current position the node from the rest of the ADD that should be here. Then returns this ADD. The key here is that the node being visited is NOT put in its proper place by this instance, but rather is switched when its proper position is reached in the recursion tree.</p>
<p>The <a class="el" href="structDdNode.html" title="Decision diagram node.">DdNode</a> * that is returned is the same ADD as passed in as node, but in the new order.</p>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddCompose_8c.html#a4926a513ab721d9bbc866740d40cbfcf" title="Permutes the variables of an ADD.">Cudd_addPermute</a> <a class="el" href="cuddCompose_8c.html#aafe391f4d9382e7ac57e6bfae5d35eab" title="Implements the recursive step of Cudd_bddPermute.">cuddBddPermuteRecur</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">manager</td><td>DD manager </td></tr>
    <tr><td class="paramname">table</td><td>computed table </td></tr>
    <tr><td class="paramname">node</td><td>ADD to be reordered </td></tr>
    <tr><td class="paramname">permut</td><td>permutation array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0724509f334eefd7b42fb863960fd5ce"></a><!-- doxytag: member="cuddCompose.c::cuddAddVectorComposeRecur" ref="a0724509f334eefd7b42fb863960fd5ce" args="(DdManager *dd, DdHashTable *table, DdNode *f, DdNode **vector, int deepest)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structDdNode.html">DdNode</a>* cuddAddVectorComposeRecur </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdHashTable.html">DdHashTable</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>deepest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs the recursive step of Cudd_addVectorCompose. </p>
<dl class="user"><dt><b>Side effects</b></dt><dd>None </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>DD manager </td></tr>
    <tr><td class="paramname">table</td><td>computed table </td></tr>
    <tr><td class="paramname">f</td><td>ADD in which to compose </td></tr>
    <tr><td class="paramname">vector</td><td>functions to substitute </td></tr>
    <tr><td class="paramname">deepest</td><td>depth of deepest substitution </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a133d2162f21001ffd87160c1ba9ee761"></a><!-- doxytag: member="cuddCompose.c::cuddBddComposeRecur" ref="a133d2162f21001ffd87160c1ba9ee761" args="(DdManager *dd, DdNode *f, DdNode *g, DdNode *proj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* cuddBddComposeRecur </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>proj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs the recursive step of Cudd_bddCompose. </p>
<p>Exploits the fact that the composition of f' with g produces the complement of the composition of f with g to better utilize the cache.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the composed BDD if successful; NULL otherwise.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddCompose_8c.html#ab5ccb7b9d27d9d383d0f407cf894f118" title="Substitutes g for x_v in the BDD for f.">Cudd_bddCompose</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aafe391f4d9382e7ac57e6bfae5d35eab"></a><!-- doxytag: member="cuddCompose.c::cuddBddPermuteRecur" ref="aafe391f4d9382e7ac57e6bfae5d35eab" args="(DdManager *manager, DdHashTable *table, DdNode *node, int *permut)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structDdNode.html">DdNode</a>* cuddBddPermuteRecur </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdHashTable.html">DdHashTable</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>permut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements the recursive step of Cudd_bddPermute. </p>
<p>Recursively puts the BDD in the order given in the array permut. Checks for trivial cases to terminate recursion, then splits on the children of this node. Once the solutions for the children are obtained, it puts into the current position the node from the rest of the BDD that should be here. Then returns this BDD. The key here is that the node being visited is NOT put in its proper place by this instance, but rather is switched when its proper position is reached in the recursion tree.</p>
<p>The <a class="el" href="structDdNode.html" title="Decision diagram node.">DdNode</a> * that is returned is the same BDD as passed in as node, but in the new order.</p>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddCompose_8c.html#afa877bf86c670ea10d67d4f6e91fcc98" title="Permutes the variables of a BDD.">Cudd_bddPermute</a> <a class="el" href="cuddCompose_8c.html#ab5857292c431da5fa962b23c0ccabda2" title="Implements the recursive step of Cudd_addPermute.">cuddAddPermuteRecur</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">manager</td><td>DD manager </td></tr>
    <tr><td class="paramname">table</td><td>computed table </td></tr>
    <tr><td class="paramname">node</td><td>BDD to be reordered </td></tr>
    <tr><td class="paramname">permut</td><td>permutation array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a82e75c6dca2c43fb15035c0411b6342d"></a><!-- doxytag: member="cuddCompose.c::cuddBddVarMapRecur" ref="a82e75c6dca2c43fb15035c0411b6342d" args="(DdManager *manager, DdNode *f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structDdNode.html">DdNode</a>* cuddBddVarMapRecur </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements the recursive step of Cudd_bddVarMap. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the result if successful; NULL otherwise.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddCompose_8c.html#af1b6ff390b8f205a28d2804d723118d9" title="Remaps the variables of a BDD using the default variable map.">Cudd_bddVarMap</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">manager</td><td>DD manager </td></tr>
    <tr><td class="paramname">f</td><td>BDD to be remapped </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a79955dcae643990f810d79bf93fe1f72"></a><!-- doxytag: member="cuddCompose.c::cuddBddVectorComposeRecur" ref="a79955dcae643990f810d79bf93fe1f72" args="(DdManager *dd, DdHashTable *table, DdNode *f, DdNode **vector, int deepest)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structDdNode.html">DdNode</a>* cuddBddVectorComposeRecur </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdHashTable.html">DdHashTable</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> **&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>deepest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs the recursive step of Cudd_bddVectorCompose. </p>
<dl class="user"><dt><b>Side effects</b></dt><dd>None </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dd</td><td>DD manager </td></tr>
    <tr><td class="paramname">table</td><td>computed table </td></tr>
    <tr><td class="paramname">f</td><td>BDD in which to compose </td></tr>
    <tr><td class="paramname">vector</td><td>functions to be composed </td></tr>
    <tr><td class="paramname">deepest</td><td>depth of the deepest substitution </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aba2fa818c76d5302d83929ee4402da39"></a><!-- doxytag: member="cuddCompose.c::ddIsIthAddVar" ref="aba2fa818c76d5302d83929ee4402da39" args="(DdManager *dd, DdNode *f, unsigned int i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int ddIsIthAddVar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Comparison of a function to the i-th ADD variable. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if the function is the i-th ADD variable; 0 otherwise.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="af318178b1f1071db47c7e268673b6631"></a><!-- doxytag: member="cuddCompose.c::ddIsIthAddVarPair" ref="af318178b1f1071db47c7e268673b6631" args="(DdManager *dd, DdNode *f, DdNode *g, unsigned int i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int ddIsIthAddVarPair </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&#160;</td>
          <td class="paramname"><em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Comparison of a pair of functions to the i-th ADD variable. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if the functions are the i-th ADD variable and its complement; 0 otherwise.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None </dd></dl>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Thu May 12 2022 22:59:10 for cudd by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
